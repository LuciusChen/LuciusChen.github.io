<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>top-node on Lucius&#39;s PKM</title>
    <link>https://luciuschen.github.io/tags/top-node/</link>
    <description>Recent content in top-node on Lucius&#39;s PKM</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 13 Jun 2022 19:01:55 +0800</lastBuildDate><atom:link href="https://luciuschen.github.io/tags/top-node/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Distribution System</title>
      <link>https://luciuschen.github.io/posts/main/20220602202933-distribution_system/</link>
      <pubDate>Mon, 13 Jun 2022 19:01:55 +0800</pubDate>
      
      <guid>https://luciuschen.github.io/posts/main/20220602202933-distribution_system/</guid>
      <description>Remote Procedure Call Remote Procedure Call (RPC) 使得调用远程函数就像调用本地函数一样，这样就不需要关心资源的具体问题，实际上 RPC 是将方法调用转换成了网络通信。但是遇到通信失败怎</description>
      <content:encoded><![CDATA[<h2 id="remote-procedure-call">Remote Procedure Call</h2>
<p><a href="/posts/main/20220603220847-remote_procedure_call_rpc/">Remote Procedure Call (RPC)</a> 使得调用远程函数就像调用本地函数一样，这样就不需要关心资源的具体问题，实际上 RPC 是将方法调用转换成了网络通信。但是遇到通信失败怎么办？</p>
<ol>
<li>如果在函数调用过程中，服务挂了？</li>
<li>如果消息丢失了？</li>
<li>如果消息延迟了？</li>
<li>如果出了问题，回复消息是否安全？</li>
</ol>
<p>要解决这些问题，就需要将网络以及节点之间的情况抽象出来，以及时序的问题。在设计分布式算法时，需要更加抽象一点，以便更好的推理整个过程。</p>
<h2 id="system-model">System model</h2>
<h3 id="network-behaviour">Network behaviour</h3>
<p><a href="/posts/main/20220602202247-the_two_generals_problem/">The two generals problem</a> 描述了网络通信丢失的场景。</p>
<p>假设两个节点之是间双向的点对点的通信。</p>
<h4 id="reliable-links">Reliable links</h4>
<p>一条消息只会在被一个节点发送的时候才会收到，并且消息是可以重新排序的。</p>
<p>中间没有伪造消息等行为，发送了就一定会被收到。</p>
<h4 id="fair-loss-links">Fair-loss links</h4>
<p>消息可能会丢失、重复或重新排序，如果你一直重新发送，消息终将会传递过去。</p>
<p>每次发送消息成功的概率都是非零，这个时候只要一直重试，我们就假设消息一定会传递到另外一个节点。</p>
<p><strong>Fair-losl links 其实可以通过不断的重试以及并且对重复收到的消息去重，就可以达到 Reliable links 的效果。</strong></p>
<h4 id="arbitrary-links">Arbitrary links</h4>
<p>可能传递过程中会有恶意的第三方对消息进行干预。</p>
<p>比如公共场合的公共 WiFi 就会出现这种情况。</p>
<p><strong>Arbitrary links 通过 TLS 的加持，就可以达到 Fair-loss links 的效果。</strong></p>
<h3 id="nodes-behaviour">Nodes behaviour</h3>
<p><a href="/posts/main/20220602202317-the_byzantine_generals_problem/">The Byzantine generals problem</a> 描述了节点出错，导致全体协作策略失败以及容错率的问题。</p>
<p>假设每个节点都执行指定的算法，假设有以下情况。</p>
<h4 id="crash-stop--fail-stop">Crash-stop (fail-stop)</h4>
<p>如果一个节点出现问题挂了，并且在这之后永远停机。</p>
<h4 id="crash-recovery--fail-recovery">Crash-recovery (fail-recovery)</h4>
<p>一个节点挂了，并丢失了内存状态，但会在过段时间后恢复。</p>
<h4 id="byzantine-fail-arbitrary">Byzantine （fail-arbitrary)</h4>
<p>节点偏离了原本的算法，可能会发生任何事情，包括崩溃或者恶意的行为。</p>
<h3 id="synchrony--timing--assumption">Synchrony (timing) assumption</h3>
<h4 id="synchronous">Synchronous</h4>
<p>消息延迟不超过已知的上限。到达这个上限后，消息要么被传递，要么丢失。节点以已知的速度执行算法。每一步代码的执行都有执行时间的上限。</p>
<h4 id="partically-synchronous">Partically synchronous</h4>
<p>系统中一部分时间内是异步的，另一部分是同步的。</p>
<h4 id="asynchronous">Asynchronous</h4>
<p>消息可以任意地被延迟，节点可以任意地暂停，并没有时序上的保证。</p>
<h2 id="clocks-and-time-in-distributed-systems">Clocks and time in distributed systems</h2>
<p>分布式系统中经常涉及到需要测量时间，比如：</p>
<ul>
<li>Schedulers, timeouts, failure detectors, retry timers</li>
<li>Performance measurements, statistics, profiling (performance analysis也称为profiling)</li>
<li>Log files &amp; databases: record when an event occurred</li>
<li>Data with time-limited validity (e.g. cache entries)</li>
<li><strong>Determining order of events across several nodes</strong></li>
</ul>
<p>分布式系统中会遇到两种类型的时钟：</p>
<ul>
<li>physical clocks: count number of seconds elapsed</li>
<li>logical clocks: count events, e.g. messages sent</li>
</ul>
<h3 id="clock-synchronisation">Clock synchronisation</h3>
<p>物理时钟会有时间上的偏移，通常是通过和电脑、手机、电视等相对准确的地方来校准物理时钟的时间，比如手表，老式的钟摆。</p>
<p>电脑上的时间同样会有偏移，是通过 <a href="/posts/main/20220602202411-network_time_protocol_ntp/">Network Time Protocol(NTP)</a> 来校准电脑的时间，也就是物理时钟的校准。</p>
<h2 id="broadcast-protocols-and-logical-time">Broadcast protocols and logical time</h2>
<figure>
    <img loading="lazy" src="/ox-hugo/ordering-of-messages.png"
         alt="Figure 1: ordering-of-messages"/> <figcaption>
            <p><span class="figure-number">Figure 1: </span>ordering-of-messages</p>
        </figcaption>
</figure>

<p>m1 = &ldquo;A says: The moon is made of cheese!&rdquo;</p>
<p>m2 = &ldquo;B says: Oh no it isn&rsquo;t!&rdquo;</p>
<p>User C sees m2 first, m1 second, even though logically m1 <strong>happened before</strong> m2.</p>
<p><strong>Problem</strong>: even with synced clocks, t2 &lt; t1 is possible. Timestamp order is inconsistent with expected order!</p>
<p>即便我们已经通过 NTP 尽量保证物理时钟上的同步，但这个时候依旧会发生因果关系不一致的情况，所以这个时候就需要逻辑时钟。</p>
<p>逻辑时钟是在分布式系统中专门用于捕获系统中发生事件之间的因果关系，因此逻辑时钟其实就是一种计数器，每次事件发生的时候都会往前递增，所以随着事件的发生它会随着时间向前移动，但它和物理时间并没有实际的关系。</p>
<h3 id="logical-time">Logical time</h3>
<p>Logical clocks: designed to <strong>capture causal dependencies</strong>.</p>
<p>(e<sub>1</sub> → e<sub>2</sub>) ⇒ (T(e<sub>1</sub>) &lt; T(e<sub>2</sub>))<sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup></p>
<p>当事件1发生在事件2之前，那么事件1的时间戳应该小于事件2的时间戳，这是逻辑时钟要保证的最基本的原则。</p>
<p>下面将研究一下两种逻辑时钟：</p>
<ul>
<li>
<p><a href="/posts/main/20220609201658-lamport_clocks/">Lamprot Clocks</a> 是在分布式系统中的每个节点都维护一个计数器，每一个当前节点事件 <code>e</code> 发生时自增 ；发送消息时，也会附带上当前节点的计数 <code>t</code> ，消息接收者收到消息后，取出消息中的计数器与当前节点计数器比较，去最大值后自增 1。</p>
<p>这样可以实现局部顺序，再加上节点名称，形成(时间戳，节点名称)的组合后，就可以扩展为全局顺序。</p>
<p>但这样也有缺点，算法在时间戳相同，节点名称不同的平行事件的顺序判定时，会出现与实际情况不符的情况。<sup id="fnref:2"><a href="#fn:2" class="footnote-ref" role="doc-noteref">2</a></sup></p>
</li>
<li>
<p><a href="/posts/main/20220602235916-vector_clocks/">Vector Clocks</a> 除了矢量之外，矢量时钟算法与 Lamport 时钟非常相似。一个节点的矢量时钟的初始值是系统中的每个节点的事件数，也就是 0。每当节点 N<sub>i</sub> 发生事件时，它就会增加其向量钟中的第 i 个条目（它自己的条目）。(In practice, this vector is often implemented as a map from node IDs to integers rather than an array of integers. 在实践中，这里的向量通常是节点 ID 对应 Integer 的 map，而不是 Integer 的数组。)。当一个消息在网络上被发送时，发送者当前的向量时间戳被附加到该消息上。最后，当一个消息被接收时，接收者将消息中的向量时间戳与它的本地时间戳合并，方法是取两个向量的元素的最大值，然后接收者增加它自己的条目</p>
<p>这样就可以弥补 Lamport 的缺点，可以完全确定每个事件的因果顺序。</p>
</li>
</ul>
<h3 id="delivery-order-in-broadcast-protocols">Delivery order in broadcast protocols</h3>
<p>许多网络提供点对点（单播）的信息传递，其中一个信息有一个特定的收件人。现在来看看广播协议，它对网络进行了概括，使一条信息被发送到某个组的所有节点。组的成员可能是固定的，或者系统可能提供节点加入和离开组的机制。</p>
<p>一些局域网在硬件层面提供组播或广播（例如，IP 组播），但互联网上的通信通常只允许单播。此外，硬件级的组播通常是在 best-effort 基础上提供的，允许消息被丢弃；要使其可靠，需要类似于这里讨论的重传协议。</p>
<p>上面提到的 node behaviour 和 synchrony 的系统模型假设直接延伸到广播组。</p>
<h4 id="broadcast-protocols">Broadcast protocols</h4>
<p>Broadcast (multicast) is <strong>group communication</strong>:</p>
<ul>
<li>一个节点发送消息，所有组内节点传递。</li>
<li>组内成为可以是固定的也可以是动态的</li>
<li>如果一个节点发生错误，剩余的组内成员顶上。</li>
<li>Note: 这个观念比 IP 组播更加普遍</li>
</ul>
<p>建立在之前讲到的系统模型上：</p>
<ul>
<li>可以是 <strong>best-effort</strong> (may drop messages) 或者 <strong>reliable</strong> (non-faulty nodes deliver every message, by retransmitting dropped messages)</li>
<li>Asynchronous/ partially synchronous timing model ⇒ 消息延迟​<strong>没有上限</strong></li>
</ul>
<h4 id="receiving-versus-delivering">Receiving versus delivering</h4>
<figure>
    <img loading="lazy" src="/ox-hugo/receive-versus-deliver.png"
         alt="Figure 2: receive-versus-deliver"/> <figcaption>
            <p><span class="figure-number">Figure 2: </span>receive-versus-deliver</p>
        </figcaption>
</figure>

<p>假定网络提供点对点的发送/接收，在广播算法​从网络中​<strong>收到</strong>​消息后，传递给应用前会在缓存或者队列当中。</p>
<p>下面将研究三种不同形式的「广播」。所有这些都是可靠的：每条消息最终都会被传递到每个非故障节点，但没有时间上的保证。然而，它们在每个节点上传递信息的顺序方面存在差异。事实证明，这种顺序上的差异对实现广播的算法有非常根本的影响。</p>
<h4 id="forms-of-reliable-broadcast">Forms of reliable broadcast</h4>
<ul>
<li>
<p><strong>FIFO broadcast</strong></p>
<p>如果 m<sub>1</sub> 和 m<sub>2</sub> 从相同的节点广播，并且 broadcast(m<sub>1</sub>) → broadcast(m<sub>2</sub>)，那么 m<sub>1</sub> 必然在 m<sub>2</sub> 之前被传递。</p>
</li>
<li>
<p><strong>Causal broadcast</strong></p>
<p>如果 broadcast(m<sub>1</sub>) → broadcast(m<sub>2</sub>) 那么 m<sub>1</sub> 必然在 m<sub>2</sub> 之前被传递。</p>
</li>
<li>
<p><strong>Total order broadcast</strong></p>
<p>如果在同一个节点 m<sub>1</sub> 在 m<sub>2</sub> 之前被传递，那么所有节点 m<sub>1</sub> 必然在 m<sub>2</sub> 之前被传递。</p>
</li>
<li>
<p><strong>FIFO-total order broadcast</strong></p>
<p>是 FIFO broadcast 和 Total order broadcast 的结合</p>
</li>
</ul>
<h4 id="fifo-broadcast">FIFO broadcast</h4>
<p>最弱的广播类型称为先进先出（FIFO）广播。在这个模型中，由同一节点发送的信息按照发送的顺序传递。例如下图中，m<sub>1</sub> 必须在 m<sub>3</sub> 之前被传递，因为它们都是由 A 发送的。然而，m<sub>2</sub> 可以在 m<sub>1</sub> 和 m<sub>3</sub> 之前、之间或之后的任何时间被传递。</p>
<figure>
    <img loading="lazy" src="/ox-hugo/FIFO-broadcast.png"
         alt="Figure 3: FIFO-broadcast"/> <figcaption>
            <p><span class="figure-number">Figure 3: </span>FIFO-broadcast</p>
        </figcaption>
</figure>

<p>同一个节点发送的消息必须要按照发送的顺序传递，不同节点发送的消息可以是任意的顺序，比如 (m<sub>2</sub>, m<sub>1</sub>, m<sub>3</sub>)，(m<sub>1</sub>, m<sub>2</sub>, m<sub>3</sub>) 或者 (m<sub>1</sub>, m<sub>3</sub>, m<sub>2</sub>)。</p>
<p>关于这些广播协议的另一个细节：我们假设每当一个节点广播一个消息时，它也会将该消息传递给自己（在上图中用回环箭头表示）。这在一开始似乎是不必要的&ndash;毕竟，一个节点知道它自己广播了什么消息！但是，我们将在 total order broadcast 中需要这个步骤。</p>
<p>上图中的执行示例是有效的先进先出「广播」，但它违反了因果性：虽然 B 在接收了 m<sub>1</sub> 之后才广播的 m<sub>2</sub>，但节点 C 在 m<sub>1</sub> 之前就传递了 m<sub>2</sub>。Causal broadcast 提供了一个比 FIFO broadcast  更严格的排序属性。顾名思义，它确保信息按因果顺序传递：也就是说，如果一条信息的广播发生在另一条信息的广播之前，那么所有节点必须按这个顺序传递这两条信息。如果两个消息是同时广播的，一个节点可以按任何一个顺序传递它们。</p>
<h4 id="causal-broadcast">Causal broadcast</h4>
<p><strong>如果节点 C 在 m<sub>1</sub> 之前收到 m<sub>2</sub>，C 的广播算法将不得不保留（延迟或缓冲）m<sub>2</sub>，直到 m<sub>1</sub> 被传递之后，以确保消息按因果顺序传递</strong>​。在下图的例子中，消息 m<sub>2</sub> 和 m<sub>3</sub> 是​<strong>同时广播</strong>​的。节点 A 和 C 按照 m<sub>1</sub>、m<sub>3</sub>、m<sub>2</sub> 的顺序传递消息，而节点 B 按照 m<sub>1</sub>、m<sub>2</sub>、m<sub>3</sub> 的顺序传递。这些传递顺序中的任何一个都是可以接受的，因为它们都与因果关系一致。</p>
<figure>
    <img loading="lazy" src="/ox-hugo/causal-broadcast.png"
         alt="Figure 4: causal-broadcast"/> <figcaption>
            <p><span class="figure-number">Figure 4: </span>causal-broadcast</p>
        </figcaption>
</figure>

<p>有因果关系的信息必须按因果顺序传递。并行的消息可以按照任何顺序传递。</p>
<p>上图：broadcast(m<sub>1</sub>) → broadcast(m<sub>2</sub>) and broadcast(m<sub>1</sub>) → broadcast(m<sub>3</sub>) ⇒ valid orders are: (m<sub>1</sub>, m<sub>2</sub>, m<sub>3</sub>) or (m<sub>1</sub>, m<sub>3</sub>, m<sub>2</sub>)</p>
<h4 id="total-order-broadcast">Total order broadcast</h4>
<p>第三种类型的广播是总秩序广播（total order broadcast），有时也被称为原子广播（atomic broadcast）。FIFO broadcast 和 Causal broadcast 允许不同的节点以不同的顺序传递信息，total order broadcast 在各节点之间强制执行一致性，确保所有节点以相同的顺序传递信息。精确的传递顺序没有规定，只要它在所有节点上都是一样的。</p>
<figure>
    <img loading="lazy" src="/ox-hugo/total-order-broadcast-1.png"
         alt="Figure 5: total-order-broadcast-1"/> <figcaption>
            <p><span class="figure-number">Figure 5: </span>total-order-broadcast-1</p>
        </figcaption>
</figure>

<p>所有三个节点都按照 m<sub>1</sub>, m<sub>2</sub>, m<sub>3</sub> 的顺序传递消息</p>
<figure>
    <img loading="lazy" src="/ox-hugo/total-order-broadcast-2.png"
         alt="Figure 6: total-order-broadcast-2"/> <figcaption>
            <p><span class="figure-number">Figure 6: </span>total-order-broadcast-2</p>
        </figcaption>
</figure>

<p>所有三个节点都按照m<sub>1</sub>, m<sub>3</sub>, m<sub>2</sub> 的顺序传递信息。只要节点同意，这两种执行方式都是有效的。</p>
<p>与 causal broadcast 一样，节点可能需要保留消息，等待其他需要首先传递的消息。例如，节点 C 可以按任一顺序接收消息 m<sub>2</sub> 和 m<sub>3</sub> 。如果算法确定 m<sub>3</sub> 应该在 m<sub>2</sub> 之前传递，但如果节点 C 首先收到 m<sub>2</sub>，那么 C 将需要保留 m<sub>2</sub>，直到收到 m<sub>3</sub> 之后。</p>
<p>在这些图上可以看到另一个重要的细节：在 FIFO broadcast 和 causal broadcast 的情况下，当一个节点广播一个消息时，它可以立即将该消息传递给自己，而不必等待与任何其他节点的通信。这在全序广播中不再是这样：例如，在图<sub>total-order-broadcast-1</sub>上，m<sub>2</sub> 需要在 m<sub>3</sub> 之前被传递，所以节点 A 向自己传递 m<sub>3</sub> 必须等到 A 从 B 那里收到 m<sub>2</sub> 之后。</p>
<p>最后，FIFO-total order broadcast 和 total order broadcast 很像，多了一个先进先出的要求，即同一节点广播的任何消息都按其发送的顺序交付。实际上图<sub>total-order-broadcast-1</sub> 和图<sub>total-order-broadcast-2</sub> 的例子就是有效的 FIFO-total order broadcast，因为 m<sub>1</sub> 都是在 m<sub>3</sub> 之前被传递的。</p>
<h4 id="relationships-between-broadcast-models">Relationships between broadcast models</h4>
<figure>
    <img loading="lazy" src="/ox-hugo/broadcast-models-relationship.png"
         alt="Figure 7: broadcast-models-relationship"/> <figcaption>
            <p><span class="figure-number">Figure 7: </span>broadcast-models-relationship</p>
        </figcaption>
</figure>

<p>FIFO-total order broadcast 是一个严格意义上比因果广播更强的模型；换句话说，每个有效的 FIFO-total order broadcast 协议也是一个有效的 causal broadcast 协议（反过来就不是了），其他协议也是如此。</p>
<h3 id="broadcast-algorithms">Broadcast algorithms</h3>
<p>实现广播算法，简单来说，涉及到两个步骤。</p>
<ol>
<li>确保每个节点都能收到每天消息</li>
<li>以正确的顺序传递这些消息</li>
</ol>
<p>首先研究如何可靠地传递消息，当一个节点想要广播一条消息时，它就单独向其他每个节点发送消息，使用上面提到过的 reliable links。但很可能一条消息丢失，发送的节点在重新发送前就崩溃了，这种情况下，丢失的这条消息对应的节点就无法接收到这条消息。</p>
<p>为了提高可靠性，可以让其他节点帮忙。例如，当一个节点第一次收到一个特定消息时，它就把消息转发给其他每个节点（这种被称为急性可靠广播（Eager reliable broadcast））。这种算法确保了即使一些节点崩溃，所有剩下的非故障的节点都会收到每条消息。然而，这种算法很低效：在没有故障的情况下，每条消息在由 n 个节点组成的小组中要发送 O(n<sup>2</sup>) 次，每个节点要收到每条消息 n-1 次，意味着占用了大量的带宽。</p>
<p>eager reliable broadcast 的变体沿着不同维度（比如容错性、所有节点接收消息的时间和被使用的带宽）优化，其中最常见的是流言协议（Gossip protocols，也被叫做流行病协议（Epidemic protocols））。在这些协议中，一个想广播消息的节点将其发送给随机选择的少量固定数量的节点。第一次收到信息时，一个节点会将其转发给固定数量的随机选择的节点。这类似于流言、谣言或传染病在人群中的传播方式。</p>
<p>Gossip protocols 并不能保证所有节点都能收到消息：在随机选择节点时，有可能总是遗漏了一些节点。然而，如果算法的参数选择得当，信息不被传递的概率很小。Gossip protocols 很有吸引力，在正确的参数下，对消息丢失和节点崩溃有很强的弹性，同时还能保持高效。其实核裂变的发生过程，也类似于这种协议。</p>
<p>可以在 eager reliable broadcast 或 gossip protocol 的基础上，建立 FIFO、causal 或者 total order broadcast。</p>
<h4 id="fifo-broadcast-algorithm">FIFO broadcast algorithm</h4>
<blockquote>
<p><strong>on</strong> initialisation <strong>do</strong></p>
<p>sendSeq := 0; delivered := 〈0, 0, &hellip;, 0〉; buﬀer := {}</p>
<p><strong>end on</strong></p>
<p><strong>on</strong> request to broadcast <code>m</code> at node N<sub>i</sub> <strong>do</strong></p>
<p>send (i, sendSeq, m) via reliable broadcast</p>
<p>sendSeq := sendSeq + 1</p>
<p><strong>end on</strong></p>
<p><strong>on</strong> receiving <code>msg</code> from reliable broadcast at node N<sub>i</sub> <strong>do</strong> ▻ msg 就是 (i, sendSeq, m)</p>
<p>buﬀer := buﬀer ∪ {msg}</p>
<p><strong>while</strong> ∃sender, m. (sender, delivered[sender], m) ∈ buﬀer <strong>do</strong> ▻ delivered[sender] 就是根据节点的编号 i 取出 delivered 中对应条目，也就是 sendSeq。</p>
<p>deliver <code>m</code> to the application</p>
<p>delivered[sender] := delivered[sender] + 1 ▻ delivered[sender] 就是当前要传递的消息的 sendSeq，+ 1 预期的下个需要传递消息的序列号。</p>
<p><strong>end while</strong></p>
<p><strong>end on</strong></p>
</blockquote>
<p>节点 N<sub>i</sub> 发送的每个 FIFO broadcast 消息都会附带发送节点编号 i 和一个序列号（该节点发送消息对应的序列号，第一条消息对应为 0，第二条消息对应为 1）。每个节点的本地状态由序列号 sendSeq（计算该节点广播的消息数量）、delivered（一个向量，每个节点有一个条目，统计了每个节点发送消息并传递到该节点的数量）和 buﬀer（一个缓存，用于保留消息直到它们准备好被传递给 Application，也就是 Receiving versus delivering 中提到的 deliver 阶段）组成。该算法检查来自任何发送者的与预期的下一个序列号相匹配的消息，然后递增该序列号，确保来自每个特定发送者的消息按照序列号递增的顺序被传递。</p>
<p>Causal broadcast 算法有点类似于 FIFO broadcast；这里不是给每条被广播的消息附上一个序列号，而是附上一个整数的向量。这种算法有时被称为矢量时钟算法，矢量时钟算法中，矢量元素计算每个节点发生的事件数量，而在 causal broadcast 算法中，矢量元素计算来自每个发送者的已发送的信息数量。</p>
<h4 id="causal-broadcast-algorithm">Causal broadcast algorithm</h4>
<blockquote>
<p><strong>on</strong> initialisation <strong>do</strong></p>
<p>sendSeq := 0; delivered := 〈0, 0, . . ., 0〉; buﬀer := {}</p>
<p><strong>end on</strong></p>
<p><strong>on</strong> request to broadcast <code>m</code> at node N<sub>i</sub> <strong>do</strong></p>
<p>deps := delivered; deps[i] := sendSeq</p>
<p>send (i, deps, m) via reliable broadcast</p>
<p>sendSeq := sendSeq + 1</p>
<p><strong>end on</strong></p>
<p><strong>on</strong> receiving <code>msg</code> from reliable broadcast at node N<sub>i</sub> <strong>do</strong></p>
<p>buﬀer := buﬀer ∪ {msg}</p>
<p><strong>while</strong> ∃(sender, deps, m) ∈ buﬀer. deps ≤ delivered <strong>do</strong></p>
<p>deliver <code>m</code> to the application</p>
<p>buﬀer := buﬀer \ {(sender, deps, m)}<sup id="fnref:3"><a href="#fn:3" class="footnote-ref" role="doc-noteref">3</a></sup></p>
<p>delivered[sender] := delivered[sender] + 1</p>
<p><strong>end while</strong></p>
<p><strong>end on</strong></p>
</blockquote>
<p>每个节点的本地状态由 sendSeq、delivered 和 buﬀer 组成，它们的含义与 FIFO broadcast 算法中相同。当一个节点想要广播一个消息时，我们会附上发送节点的编号 i 和 deps（表示该消息因果关系的向量）。deps 就是节点本地 delivered 的复制，统计了每个节点发送消息并传递到该节点的数量。在这次广播之前，所有已经在本地交付的消息必须出现在广播消息的因果顺序之前。然后将发送节点自己的这个向量的元素更新为等于 sendSeq，这就保证了这个节点所广播的每条消息都与同一节点所广播的前一条消息有因果关系。</p>
<p>当收到一个消息时，算法首先将其添加到 buﬀer 中，就像 FIFO broadcast 一样，然后在 buﬀer 中搜索任何准备好的消息。比较 deps ≤ delivered。如果这个节点已经交付了所有在因果顺序上必须在这个消息之前的消息，那么。任何在因果关系上准备好的消息都会被传递给 Application，并从 buﬀer 中移除，并且将 delivered 中的相应条目被递增。</p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p><a href="/posts/main/20220602202832-causality_and_happen_before_relation/">Causality and Happen-before relation</a>&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:2">
<p>if a || b we could have either a ≺ b or b ≺ a, so the order of the two events is determined arbitrarily by the algorithm.&#160;<a href="#fnref:2" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
<li id="fn:3">
<p>删除 buffer 中的  {(sender, deps, m)}&#160;<a href="#fnref:3" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>
]]></content:encoded>
    </item>
    
    <item>
      <title>MySQL</title>
      <link>https://luciuschen.github.io/posts/main/20220530185321-mysql/</link>
      <pubDate>Sat, 11 Jun 2022 11:51:16 +0800</pubDate>
      
      <guid>https://luciuschen.github.io/posts/main/20220530185321-mysql/</guid>
      <description>Troubleshoot Issues in MySQL
Sort Chinese text fields alphabetically by first letter</description>
      <content:encoded><![CDATA[<p><a href="/posts/main/20220530180443-troubleshoot_issues_in_mysql/">Troubleshoot Issues in MySQL</a></p>
<p><a href="/posts/main/20220601104443-sort_chinese_text_fields_alphabetically_by_first_letter/">Sort Chinese text fields alphabetically by first letter</a></p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Refactoring Code</title>
      <link>https://luciuschen.github.io/posts/main/20220506193054-refactoring_code/</link>
      <pubDate>Sat, 11 Jun 2022 11:50:30 +0800</pubDate>
      
      <guid>https://luciuschen.github.io/posts/main/20220506193054-refactoring_code/</guid>
      <description>Refactoring Code How To Find Time Complexity Of An Algorithm
JavaScript Refactoring Tips Refactoring Condition statements Converting callbacks to promises Refactoring Promise chains with async/await </description>
      <content:encoded><![CDATA[<h2 id="refactoring-code">Refactoring Code</h2>
<p><a href="/posts/main/20220506193205-how_to_find_time_complexity_of_an_algorithm/">How To Find Time Complexity Of An Algorithm</a></p>
<h3 id="javascript">JavaScript</h3>
<h4 id="refactoring-tips">Refactoring Tips</h4>
<ol>
<li><a href="/posts/main/20220506193520-refactoring_condition_statements/">Refactoring Condition statements</a></li>
<li><a href="/posts/main/20220506193545-converting_callbacks_to_promises/">Converting callbacks to promises</a></li>
<li><a href="/posts/main/20220506193624-refactoring_promise_chains_with_async_await/">Refactoring Promise chains with async/await</a></li>
</ol>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
