[{"content":"Add backlink 在 themes/xxx/layouts/partials/ 下新增 ~backlink.html~，内容如下。\n{{ $re := $.File.BaseFileName }} {{ $backlinks := slice }} {{ range .Site.AllPages }} {{ if and (findRE $re .RawContent) (not (eq $re .File.BaseFileName)) }} {{ $backlinks = $backlinks | append . }} {{ end }} {{ end }} {{ if gt (len $backlinks) 0 }} \u0026lt;div class=\u0026#34;bl-section\u0026#34;\u0026gt; \u0026lt;h4\u0026gt;Links to this note\u0026lt;/h4\u0026gt; \u0026lt;div class=\u0026#34;backlinks\u0026#34;\u0026gt; \u0026lt;ul\u0026gt; {{ range $backlinks }} \u0026lt;li\u0026gt;\u0026lt;a href=\u0026#34;{{ .RelPermalink }}\u0026#34;\u0026gt;{{ .Title }}\u0026lt;/a\u0026gt;\u0026lt;/li\u0026gt; {{ end }} \u0026lt;/ul\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; {{ else }} \u0026lt;div class=\u0026#34;bl-section\u0026#34;\u0026gt; \u0026lt;h4\u0026gt;No notes link to this note\u0026lt;/h4\u0026gt; \u0026lt;/div\u0026gt; {{ end }} 在 themes/xxx/layouts/_default/single.html 中增加下面代码，放到合适的地方。\n{{ partial \u0026#34;backlinks.html\u0026#34; . }} 放在文章下方的话可以插入如下位置\n\u0026lt;div class=\u0026#34;post-content\u0026#34;\u0026gt; {{- if not (.Param \u0026#34;disableAnchoredHeadings\u0026#34;) }} {{- partial \u0026#34;anchored_headings.html\u0026#34; .Content -}} {{- else }}{{ .Content }}{{ end }} {{ partial \u0026#34;backlinks.html\u0026#34; . }} \u0026lt;/div\u0026gt; MathJax support 方案1 在 themes/xxx/layouts/_default/single.html 中 header 中增加下面代码。\n\u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\u0026#34;\u0026gt; \u0026lt;/script\u0026gt; 方案2 增加 themes/xxx/layouts/partials/mathjax.html 文件，并在其中增加下面代码，实现即便是页面间的跳转，也可以实时渲染公式。\n\u0026lt;script\u0026gt; MathJax = { tex: { inlineMath: [[\u0026#39;$\u0026#39;, \u0026#39;$\u0026#39;], [\u0026#39;\\\\(\u0026#39;, \u0026#39;\\\\)\u0026#39;]], displayMath: [[\u0026#39;$$\u0026#39;,\u0026#39;$$\u0026#39;], [\u0026#39;\\\\[\u0026#39;, \u0026#39;\\\\]\u0026#39;]], processEscapes: true, processEnvironments: true }, options: { skipHtmlTags: [\u0026#39;script\u0026#39;, \u0026#39;noscript\u0026#39;, \u0026#39;style\u0026#39;, \u0026#39;textarea\u0026#39;, \u0026#39;pre\u0026#39;] } }; window.addEventListener(\u0026#39;load\u0026#39;, (event) =\u0026gt; { document.querySelectorAll(\u0026#34;mjx-container\u0026#34;).forEach(function(x){ x.parentElement.classList += \u0026#39;has-jax\u0026#39;}) }); \u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://polyfill.io/v3/polyfill.min.js?features=es6\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; id=\u0026#34;MathJax-script\u0026#34; async src=\u0026#34;https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; code.has-jax { font: inherit; font-size: 100%; background: inherit; border: inherit; color: #515151; } \u0026lt;/style\u0026gt; 在 themes/xxx/layouts/_default/header.html 中增加下面代码，放到合适的地方。\n{{ partial \u0026#34;mathjax.html\u0026#34; . }} 如果不想所有页面都加载 MathJax，就添加下面代码。\n{{ if .Params.mathjax }}{{ partial \u0026#34;mathjax.html\u0026#34; . }}{{ end }} 并通过 Custom Front-matter Parameters 设置 mathjax: true~。具体是添加下面代码到需要导出并用 MathJax 展示的 org 文件头部，导出后就是 ~.md 文件中的 metadata。\n#+HUGO_CUSTOM_FRONT_MATTER: :mathjax true ","permalink":"https://luciuschen.github.io/posts/main/20220607104757-hugo/","summary":"Add backlink 在 themes/xxx/layouts/partials/ 下新增 ~backlink.html~，内容如下。 {{ $re := $.File.BaseFileName }} {{ $backlinks := slice }} {{ range .Site.AllPages }} {{ if and (findRE $re .RawContent) (not (eq $re .File.BaseFileName)) }} {{ $backlinks = $backlinks | append . }} {{ end }} {{ end }} {{ if gt","title":"Hugo"},{"content":"Quorum 机制，是一种分布式系统中常用的，用来保证数据冗余和最终一致性的投票算法，其主要数学思想来源于鸽巢原理。\n基于 Quorum 投票的冗余控制算法 在有冗余数据的分布式存储系统当中，冗余数据对象会在不同的机器之间存放多份拷贝。但是同一时刻一个数据对象的多份拷贝只能用于读或者用于写。\n该算法可以保证同一份数据对象的多份拷贝不会被超过两个访问对象读写。\n分布式系统中的每一份数据拷贝对象都被赋予一票。每一个读操作获得的票数必须大于最小读票数（read quorum）（\\(V_{r}\\)），每个写操作获得的票数必须大于最小写票数（write quorum）(\\(V_{w}\\)）才能读或者写。如果系统有V票（意味着一个数据对象有 \\(V\\) 份冗余拷贝），那么最小读写票数(quorum)应满足如下限制：\n\\(V_{r} + V_{w} \u0026gt; V\\) \\(V_{w} \u0026gt; \\frac{V}{2}\\) 第一条规则保证了一个数据不会被同时读写。当一个写操作请求过来的时候，它必须要获得 \\(V_{w}\\) 个冗余拷贝的许可。而剩下的数量是 \\(V - V_{w}\\) 不够 \\(V_{r}\\)，因此不能再有读请求过来了。同理，当读请求已经获得了 \\(V_{r}\\) 个冗余拷贝的许可时，写请求就无法获得许可了。\n第二条规则保证了数据的串行化修改。一份数据的冗余拷贝不可能同时被两个写请求修改。\n算法的好处 在分布式系统中，冗余数据是保证可靠性的手段，因此冗余数据的一致性维护就非常重要。一般而言，一个写操作必须要对所有的冗余数据都更新完成了，才能称为成功结束。比如一份数据在5台设备上有冗余，因为不知道读数据会落在哪一台设备上，那么一次写操作，必须5台设备都更新完成，写操作才能返回。\n对于写操作比较频繁的系统，这个操作的瓶颈非常大。Quorum 算法可以让写操作只要写完3台就返回。剩下的由系统内部缓慢同步完成。而读操作，则需要也至少读3台，才能保证至少可以读到一个最新的数据。\nQuorum 的读写最小票数可以用来做为系统在读、写性能方面的一个可调节参数。写票数 \\(V_{w}\\) 越大，则读票数 \\(V_{r}\\) 越小，这时候系统读的开销就小。反之则写的开销就小。\n","permalink":"https://luciuschen.github.io/posts/main/20220615143721-quorum/","summary":"Quorum 机制，是一种分布式系统中常用的，用来保证数据冗余和最终一致性的投票算法，其主要数学思想来源于鸽巢原理。 基于 Quorum 投票的冗余控制算法 在有冗余数据","title":"Quorum"},{"content":"Network Time Protocol (NTP) is an internet protocol used to synchronize with computer clock time sources in a network. It belongs to and is one of the oldest parts of the TCP/IP suite. The term NTP applies to both the protocol and the client-server programs that run on computers.\nMac 中可以在设置中找到 NTP 服务器的地址，比如下图中的地址就是 time.apple.com 。\nFigure 1: NTP\nEstimating time over a network Figure 2: NTP\nRound-trip network delay: \\(\\delta = (t_{4} - t_{1}) - (t_{3} - t_{2})\\)\nEstimated server time when client receives response: \\(t_{3} + \\frac{\\delta}{2}\\)（客户端收到响应时的服务器的时间）\nEstimated clock skew: \\(\\theta = t_{3} + \\frac{\\delta}{2} - t_{4} = \\frac{(t_{2} - t_{1} + t_{3} - t_{4})}{2}\\)（计算预估的服务器时间和当前客户端时间的偏差）\nCorrecting clock skew Once the client has estimated the clock skew θ, it needs to apply that correction to its clock.\nif \\(\\theta \u0026lt; 125 ms\\), slew the clock:\nslightly speed it up or slow it down by up to \\(500 ppm\\)1 (brings clocks in sync within ≈ 5 minutes)\nif \\(125 ms \\le \\theta \u0026lt; 1000 s\\), step the clock:\nsuddenly reset client clock to estimated server timestamp\nif \\(\\theta \\ge 1000 s\\), panic and do nothing (leave the problem for a human operator to resolve)\n依靠时钟同步的系统需要监控时钟偏移。从最后一条可以看出，如果 NTP Client 和 NTP Server 偏差过大，则会拒绝同步 NTP 的时间，留给人工来处理，因此我们需要避免出现这种偏差过大的情况。\n当初初学 Java 的时候，需要知晓某个函数或某段代码执行的时间，通常会用 System.currentTimeMillis() 来测量\n原来 System.currentTimeMillis() 用来测量某个函数运行的时间是错误的，会受到 NTP 的影响（机率虽然很小）。应该用 System.nanoTime() 来测量，不会受到 NTP 很大的影响，最多影响「单调时间」步进的频率。\n1 ppm = 1 microsecond/second = 86ms/day = 32s/year (ppm 是 part per million 的简称)\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://luciuschen.github.io/posts/main/20220602202411-network_time_protocol_ntp/","summary":"Network Time Protocol (NTP) is an internet protocol used to synchronize with computer clock time sources in a network. It belongs to and is one of the oldest parts of the TCP/IP suite. The term NTP applies to both the protocol and the client-server programs that run on computers. Mac 中可以在设置中找到 NTP 服务器的地址，比如下","title":"Network Time Protocol (NTP)"},{"content":" \\rightarrow \\(\\rightarrow\\) \\longrightarrow \\(\\longrightarrow\\) \\Longrightarrow \\(\\Longrightarrow\\) \\dot\\imath \\(\\dot\\imath\\) \\iff \\(\\iff\\) \\triangleright \\(\\triangleright\\) \\ell \\(\\ell\\) \\rVert \\(\\rVert\\) \\(\\boldsymbol{012…abc…ABC…\\alpha \\beta\\gamma…}\\)\n","permalink":"https://luciuschen.github.io/posts/main/20220616162256-latex/","summary":"\\rightarrow \\(\\rightarrow\\) \\longrightarrow \\(\\longrightarrow\\) \\Longrightarrow \\(\\Longrightarrow\\) \\dot\\imath \\(\\dot\\imath\\) \\iff \\(\\iff\\) \\triangleright \\(\\triangleright\\) \\ell \\(\\ell\\) \\rVert \\(\\rVert\\) \\(\\boldsymbol{012…abc…ABC…\\alpha \\beta\\gamma…}\\)","title":"Latex"},{"content":"Definition 总秩序广播（total order broadcast），有时也被称为原子广播（atomic broadcast）。FIFO broadcast 和 Causal broadcast 允许不同的节点以不同的顺序传递信息，total order broadcast 在各节点之间强制执行一致性，确保所有节点以相同的顺序传递信息。精确的传递顺序没有规定，只要它在所有节点上都是一样的。\nFigure 1: total-order-broadcast-1\n所有三个节点都按照 \\(m_{1}\\), \\(m_{2}\\), \\(m_{3}\\) 的顺序传递消息\nFigure 2: total-order-broadcast-2\n所有三个节点都按照 \\(m_{1}\\), \\(m_{3}\\), \\(m_{2}\\) 的顺序传递信息。只要节点同意，这两种执行方式都是有效的。\n与 Causal broadcast 一样，节点可能需要保留消息，等待其他需要首先传递的消息。例如，节点 \\(C\\) 可以按任一顺序接收消息 \\(m_{2}\\) 和 \\(m_{3}\\)。如果算法确定 \\(m_{3}\\) 应该在 \\(m_{2}\\) 之前传递，但如果节点 \\(C\\) 首先收到 \\(m_{2}\\)，那么 \\(C\\) 将需要保留 \\(m_{2}\\)，直到收到 \\(m_{3}\\) 之后。\n在这些图上可以看到另一个重要的细节：在 FIFO broadcast 和 Causal broadcast 的情况下，当一个节点广播一个消息时，它可以立即将该消息传递给自己，而不必等待与任何其他节点的通信。这在全序广播中不再是这样：例如，在 图total-order-broadcast-1 上，\\(m_{2}\\) 需要在 \\(m_{3}\\) 之前被传递，所以节点 \\(A\\) 向自己传递 \\(m_{3}\\) 必须等到 \\(A\\) 从 \\(B\\) 那里收到 \\(m_{2}\\) 之后。\n最后，FIFO-total order broadcast 和 total order broadcast 很像，多了一个先进先出的要求，即同一节点广播的任何消息都按其发送的顺序交付。实际上图total-order-broadcast-1 和图total-order-broadcast-2 的例子就是有效的 FIFO-total order broadcast，因为 \\(m_{1}\\) 都是在 \\(m_{3}\\)之前被传递的。\nTotal order broadcast algorithms Single leader approach:\n指定一个节点为 leader 想要广播消息，将其发送给 leader，leader 再将其通过 FIFO broadcast 广播给其他节点。 Problem: leader 崩溃 \\(\\Longrightarrow\\) 没有消息被传递 安全地更换 leader 很困难 Lamport clocks approach:\n每条消息附带上 lamport 时间戳 按照时间戳的总顺序传递消息 Problem: 无法知道是否收到了所有时间戳小于 \\(T\\)1 的消息，需要在缓存中缓存来自每个节点时间戳大于等于 \\(T\\) 的消息。 上述两个方法，都不具有容错性。单个节点崩溃以及 leader 节点崩溃都会使得其他节点无法传递消息。\n当前节点的时间戳 \\(T\\)\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://luciuschen.github.io/posts/main/20220616135058-total_order_broadcast/","summary":"Definition 总秩序广播（total order broadcast），有时也被称为原子广播（atomic broadcast）。FIFO broadcast 和 Causal broadcast 允许不同的节点以不同","title":"Total order broadcast"},{"content":"Remote Procedure Call Remote Procedure Call (RPC) 使得调用远程函数就像调用本地函数一样，这样就不需要关心资源的具体问题，实际上 RPC 是将方法调用转换成了网络通信。但是遇到通信失败怎么办？\n如果在函数调用过程中，服务挂了？ 如果消息丢失了？ 如果消息延迟了？ 如果出了问题，回复消息是否安全？ 要解决这些问题，就需要将网络以及节点之间的情况抽象出来，以及时序的问题。在设计分布式算法时，需要更加抽象一点，以便更好的推理整个过程。\nSystem model Network behaviour The two generals problem 描述了网络通信丢失的场景。\n假设两个节点之是间双向的点对点的通信。\nReliable links 一条消息只会在被一个节点发送的时候才会收到，并且消息是可以重新排序的。\n中间没有伪造消息等行为，发送了就一定会被收到。\nFair-loss links 消息可能会丢失、重复或重新排序，如果你一直重新发送，消息终将会传递过去。\n每次发送消息成功的概率都是非零，这个时候只要一直重试，我们就假设消息一定会传递到另外一个节点。\nFair-losl links 其实可以通过不断的重试以及并且对重复收到的消息去重，就可以达到 Reliable links 的效果。\nArbitrary links 可能传递过程中会有恶意的第三方对消息进行干预。\n比如公共场合的公共 WiFi 就会出现这种情况。\nArbitrary links 通过 TLS 的加持，就可以达到 Fair-loss links 的效果。\nNodes behaviour The Byzantine generals problem 描述了节点出错，导致全体协作策略失败以及容错率的问题。\n假设每个节点都执行指定的算法，假设有以下情况。\nCrash-stop (fail-stop) 如果一个节点出现问题挂了，并且在这之后永远停机。\nCrash-recovery (fail-recovery) 一个节点挂了，并丢失了内存状态，但会在过段时间后恢复。\nByzantine （fail-arbitrary) 节点偏离了原本的算法，可能会发生任何事情，包括崩溃或者恶意的行为。\nSynchrony (timing) assumption Synchronous 消息延迟不超过已知的上限。到达这个上限后，消息要么被传递，要么丢失。节点以已知的速度执行算法。每一步代码的执行都有执行时间的上限。\nPartically synchronous 系统中一部分时间内是异步的，另一部分是同步的。\nAsynchronous 消息可以任意地被延迟，节点可以任意地暂停，并没有时序上的保证。\nClocks and time in distributed systems 分布式系统中经常涉及到需要测量时间，比如：\nSchedulers, timeouts, failure detectors, retry timers Performance measurements, statistics, profiling (performance analysis也称为profiling) Log files \u0026amp; databases: record when an event occurred Data with time-limited validity (e.g. cache entries) Determining order of events across several nodes 分布式系统中会遇到两种类型的时钟：\nphysical clocks: count number of seconds elapsed logical clocks: count events, e.g. messages sent Clock synchronisation 物理时钟会有时间上的偏移，通常是通过和电脑、手机、电视等相对准确的地方来校准物理时钟的时间，比如手表，老式的钟摆。\n电脑上的时间同样会有偏移，是通过 Network Time Protocol(NTP) 来校准电脑的时间，也就是物理时钟的校准。\nBroadcast protocols and logical time Figure 1: ordering-of-messages\n\\(m_{1}\\) = \u0026ldquo;A says: The moon is made of cheese!\u0026rdquo;\n\\(m_{2}\\) = \u0026ldquo;B says: Oh no it isn\u0026rsquo;t!\u0026rdquo;\nUser C sees \\(m_{2}\\) first, \\(m_{1}\\) second, even though logically \\(m_{1}\\) happened before \\(m_{2}\\).\nProblem: even with synced clocks, \\(t_{2 }\u0026lt; t_{1}\\) is possible. Timestamp order is inconsistent with expected order!\n即便我们已经通过 NTP 尽量保证物理时钟上的同步，但这个时候依旧会发生因果关系不一致的情况，所以这个时候就需要逻辑时钟。\n逻辑时钟是在分布式系统中专门用于捕获系统中发生事件之间的因果关系，因此逻辑时钟其实就是一种计数器，每次事件发生的时候都会往前递增，所以随着事件的发生它会随着时间向前移动，但它和物理时间并没有实际的关系。\nLogical time Logical clocks: designed to capture causal dependencies.\n\\((e_{1} \\rightarrow e_{2}) \\Longrightarrow (T(e_{1}) \u0026lt; T(e_{2}))\\)1\n当事件1发生在事件2之前，那么事件1的时间戳应该小于事件2的时间戳，这是逻辑时钟要保证的最基本的原则。\n下面将研究一下两种逻辑时钟：\nLamprot clocks 是在分布式系统中的每个节点都维护一个计数器，每一个当前节点事件 \\(e\\) 发生时自增 ；发送消息时，也会附带上当前节点的计数 \\(t\\) ，消息接收者收到消息后，取出消息中的计数器与当前节点计数器比较，去最大值后自增 1。\n这样可以实现局部顺序，再加上节点名称，形成(时间戳，节点名称)的组合后，就可以扩展为全局顺序。\n但这样也有缺点，算法在时间戳相同，节点名称不同的平行事件的顺序判定时，会出现与实际情况不符的情况。2\nVector clocks 除了是向量之外，向量时钟算法与 Lamport 时钟非常相似。一个节点的向量时钟的初始值是系统中的每个节点的事件数，也就是 0。每当节点 \\(N_{i}\\) 发生事件时，它就会增加其向量钟中的第 \\(i\\) 个条目（它自己的条目）。(In practice, this vector is often implemented as a map from node IDs to integers rather than an array of integers. 在实践中，这里的向量通常是节点 ID 对应 Integer 的 map，而不是 Integer 的数组。)。当一个消息在网络上被发送时，发送者当前的向量时间戳被附加到该消息上。最后，当一个消息被接收时，接收者将消息中的向量时间戳与它的本地时间戳合并，方法是取两个向量的元素的最大值，然后接收者增加它自己的条目\n这样就可以弥补 Lamport 的缺点，可以完全确定每个事件的因果顺序。\nDelivery order in broadcast protocols 许多网络提供点对点（单播）的信息传递，其中一个信息有一个特定的收件人。广播协议对网络进行了概括，使一条信息被发送到某个组的所有节点。组的成员可能是固定的，或者系统可能提供节点加入和离开组的机制。\n一些局域网在硬件层面提供组播或广播（例如，IP 组播），但互联网上的通信通常只允许单播。此外，硬件级的组播通常是在 best-effort 基础上提供的，允许消息被丢弃；要使其可靠，需要类似于这里讨论的重传协议。\n上面提到的 node behaviour 和 synchrony 的系统模型假设直接延伸到广播组。\nBroadcast protocols Broadcast (multicast) is group communication:\n一个节点发送消息，所有组内节点传递。 组内成为可以是固定的也可以是动态的 如果一个节点发生错误，剩余的组内成员顶上。 Note: 这个观念比 IP 组播更加普遍 建立在之前讲到的系统模型上：\n可以是 best-effort (可能会丢失消息) 或者 reliable (非故障节点传递每条消息，重传丢失的消息。) Asynchronous / partially synchronous timing model \\(\\Longrightarrow\\) 消息延迟​没有上限 Receiving versus delivering Figure 2: receive-versus-deliver\n假定网络提供点对点的发送/接收，在广播算法​从网络中​收到​消息后，传递给应用前会在缓存或者队列当中。\n下面将研究三种不同形式的「广播」。所有这些都是可靠的：每条消息最终都会被传递到每个非故障节点，但没有时间上的保证。然而，它们在每个节点上传递信息的顺序方面存在差异。事实证明，这种顺序上的差异对实现广播的算法有非常根本的影响。\nForms of reliable broadcast FIFO broadcast\n如果 \\(m_{1}\\) 和 \\(m_{2}\\) 从相同的节点广播，并且 broadcast(\\(m_{1}\\)) \\(\\longrightarrow\\) broadcast(\\(m_{2}\\))，那么 \\(m_{1}\\) 必然在 \\(m_{2}\\) 之前被传递。\nCausal broadcast\n如果 broadcast(\\(m_{1}\\)) \\(\\longrightarrow\\) broadcast(\\(m_{2}\\)) 那么 \\(m_{1}\\) 必然在 \\(m_{2}\\) 之前被传递。\nTotal order broadcast\n如果在同一个节点 \\(m_{1}\\) 在 \\(m_{2}\\) 之前被传递，那么所有节点 \\(m_{1}\\) 必然在 \\(m_{2}\\) 之前被传递。\nFIFO-total order broadcast\n是 FIFO broadcast 和 Total order broadcast 的结合\nRelationships between broadcast models Figure 3: broadcast-models-relationship\nFIFO-total order broadcast 是一个严格意义上比因果广播更强的模型；换句话说，每个有效的 FIFO-total order broadcast 协议也是一个有效的 causal broadcast 协议（反过来就不是了），其他协议也是如此。\nBroadcast algorithms 实现广播算法，简单来说，涉及到两个步骤。\n确保每个节点都能收到每天消息 以正确的顺序传递这些消息 首先研究如何可靠地传递消息，当一个节点想要广播一条消息时，它就单独向其他每个节点发送消息，使用上面提到过的 reliable links。但很可能一条消息丢失，发送的节点在重新发送前就崩溃了，这种情况下，丢失的这条消息对应的节点就无法接收到这条消息。\n为了提高可靠性，可以让其他节点帮忙。例如，当一个节点第一次收到一个特定消息时，它就把消息转发给其他每个节点（这种被称为急性可靠广播（Eager reliable broadcast））。这种算法确保了即使一些节点崩溃，所有剩下的非故障的节点都会收到每条消息。然而，这种算法很低效：在没有故障的情况下，每条消息在由 \\(n\\) 个节点组成的小组中要发送 \\(O(n^{2})\\) 次，每个节点要收到每条消息 \\(n-1\\) 次，意味着占用了大量的带宽。\neager reliable broadcast 的变体沿着不同维度（比如容错性、所有节点接收消息的时间和被使用的带宽）优化，其中最常见的是流言协议（Gossip protocols，也被叫做流行病协议（Epidemic protocols））。在这些协议中，一个想广播消息的节点将其发送给随机选择的少量固定数量的节点。第一次收到信息时，一个节点会将其转发给固定数量的随机选择的节点。这类似于流言、谣言或传染病在人群中的传播方式。\nGossip protocols 并不能保证所有节点都能收到消息：在随机选择节点时，有可能总是遗漏了一些节点。然而，如果算法的参数选择得当，信息不被传递的概率很小。Gossip protocols 很有吸引力，在正确的参数下，对消息丢失和节点崩溃有很强的弹性，同时还能保持高效。其实核裂变的发生过程，也类似于这种协议。\n可以在 eager reliable broadcast 或 gossip protocol 的基础上，建立 FIFO、causal 或者 total order broadcast。\nFIFO broadcast algorithm Causal broadcast algorithm Total order broadcast algorithms Replication 现在要讨论的是复制的问题，也就是在多个节点上维护相同数据的副本，每个节点被称为副本。复制是许多分布式数据库、文件系统和其他存储系统的一个标准特征。它是我们实现容错的主要机制之一：如果一个副本出现故障，我们可以继续访问其他副本上的数据副本。\n在不同节点维护相同数据的副本 数据库、文件系统、缓存等等 维护相同数据的节点叫做副本 如果一些副本出错，其他副本依旧是可访问的。 将负载分散到多个副本 如果数据没有变化，维护很简单，只需要复制。 专注于数据变化 相较于 RAID (Redundant Array of Independent Disks)：在单个计算机内复制。\nRAID 只有一个控制器；在分布式系统中，每个节点都是独立的。 副本可以在全世界靠近用户的地方分布（CDN 本质其实是一种大规模分布式多级缓存系统） Manipulating remote state 在更新不同节点数据时，丢失数据或者丢失 TCP 返回的 \\(ACK\\)3 时，就会使得不同节点之间的副本不一致，不满足幂等性（Idempotent）。为了解决这个问题，可以给每次更新操作都加上一个逻辑时间戳，并将其作为数据存储在数据库当中；当需要删除这条记录时，实际上并没有删除，而是写入一个特殊的值（称为墓碑 tombstone），将其标记为删除。（其实就类似于软删除）\nFigure 4: reconciling-replicas\n在许多副本系统中，副本运行一个协议来检测和调和任何差异（这被称为反熵 anti-entropy），以便副本最终持有相同数据的一致副本。由于有了 tombstone，反熵过程可以分辨出已经被删除的记录和尚未被创建的记录之间的差异。由于有了逻辑时间戳，可以分辨出一条记录的哪个版本比较老，哪个版本比较新。然后，反熵过程会保留较新的记录并丢弃较旧的记录。\nFigure 5: concurrent-reconciling-replicas\n如果同时两个请求分别想把两个副本的 \\(x\\) 的值进行修改。\nLast writer wins (LWW):\n采用 Lamport clocks 时，\\(t_{2} \\gt t_{1}\\)则保留 \\(v_{2}\\) 丢弃 \\(v_{1}\\)。\nMulti-value register:\n采用 Vector clocks 时，\\(t_{2 }\\gt t_{1}\\) 则保留 \\(v_{2}\\) 丢弃 \\(v_{1}\\); \\(t_{2} \\rVert t_{1}\\) 则 \\(\\{v_{1}, v_{2}\\}\\) 都保留。\n向量时钟的缺点是它们会变得很昂贵：每个客户端都需要在向量中输入一个条目，在有大量客户端的系统中（或者客户端每次重启都会有新的身份），这些向量会变得很大，可能会比数据本身占用更多内存。更多类型的逻辑时钟，如点状版本向量（Dotted version vectors）4，已经被开发出来以优化这种类型的系统。\nQuorums 具体如何进行复制的细节对系统的可靠性有很大影响。如果没有容错，拥有多个副本会使可靠性变差：副本越多，任何一个副本在任何时候出现故障的概率就越大（假设故障不是完全相关的）。然而，如果系统在一些有问题的复制体中仍然继续工作，那么可靠性就会提高：所有副本在同一时间出现问题的概率要比一个复制体出现问题的概率低很多。\nRead-after-write consistency Figure 6: read-after-write-consistency\n一个副本写入了数据，从另外一个副本读取，用户并没有读取到他刚刚提交的内容。如果要保持读写一致性（read-after-write consistency），则要两个节点都同时写入和读取，一旦有一个不可访问就会破坏读写一致性，没有任何容错率可言。\nQuorum (2 out of 3) 通过使用三个副本来解决这个难题，。我们将每个读写请求发送到所有三个副本，但只要收到 \\(≥2\\) 个响应，我们就认为请求成功。在这个例子中，写在复制体B和C上成功，而读在复制体A和B上成功。对读和写都采用 \u0026ldquo;三选二 \u0026ldquo;的策略，可以保证至少有一个对读的响应来自看到最近写的复制体（在这个例子中，这是复制体B）。\nFigure 7: quorum\nReference Cachin, Guerraoui, Rodrigues (2011) Introduction to Reliable and Secure Distributed Programming (2. Ed.)., Springer. Causality and Happen-before relation\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nif \\(a \\rVert b\\) we could have either \\(a ≺ b\\) or \\(b ≺ a\\), so the order of the two events is determined arbitrarily by the algorithm.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n后面整理 TCP 相关内容时，可以加个链接。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n待学习\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://luciuschen.github.io/posts/main/20220602202933-distribution_system/","summary":"Remote Procedure Call Remote Procedure Call (RPC) 使得调用远程函数就像调用本地函数一样，这样就不需要关心资源的具体问题，实际上 RPC 是将方法调用转换成了网络通信。但是遇到通信失败怎","title":"Distribution System"},{"content":"Lamport clocks algorithm on initialisation do\n\\(t := 0\\) ▻ each node has its own local variable t\nend on\non any event occurring at the local node do\n\\(t := t + 1\\)\nend on\non request to send message \\(m\\) do\n\\(t := t + 1\\); send \\((t, m)\\) via the underlying network link\nend on\non receiving \\((t′, m)\\) via the underlying network link do\n\\(t := max(t, t′) + 1\\)\ndeliver \\(m\\) to the application\nend on\nLamport clocks in words Figure 1: lamport-example-simple\n每个节点都维护一个计数器 \\(t\\)，每一个当前节点事件 \\(e\\) 发生时，自增 1。 增长后的值设为 \\(L(e)\\) 发送消息时附带上当前的计数 \\(t\\) 消息接受者在消息中的时间戳和当前节点的时间戳之间取最大值后自增 1 Properties of this scheme:\nif \\(a \\rightarrow b\\) then \\(L(e) \u0026lt; L(b)\\) However, \\(L(a) \u0026lt; L(b)\\) does not imply \\(a \\rightarrow b\\) Possible that \\(L(a) = L(b)\\) for \\(a \\ne b\\) Lamport 时间戳本质上是一个整数，用来计算已发生事件的数量。因此，它与物理时间没有直接关系。在每个节点上，时间都会增加，因为每个事件的整数都会递增。该算法假设了一个 crash-stop 模型（如果时间戳被保持在稳定的存储中，即在磁盘上，则是 crash-recovery 模型）。\nLamport clocks example Figure 2: lamport-example\nLet \\(N(e)\\) be the node at which event \\(e\\) occurred.\nThen the pair \\((L(e), N(e))\\) uniquely identiﬁes event \\(e\\).\nDeﬁne a total order \\(≺\\) using Lamport timestamps:\n\\((a ≺ b) \\iff (L(a) \u0026lt; L(b) ∨ (L(a) = L(b) ∧ N(a) \u0026lt; N(b)))\\)1, 2\nThis order is causal: \\((a → b) \\Longrightarrow (a ≺ b)\\)\n回顾之前的 happens-before relation 是局部顺序。利用 Lamport 时间戳可以将这种局部的顺序扩展到全局顺序。可以用（时间戳, 节点名称) 组合：首先比较时间戳，如果相同，则比较节点名称。\n对于任何两个事件 \\(a \\ne b\\)，那么既不是 \\(a ≺ b\\) 也不是 \\(b ≺ a\\)。只要 \\(a → b\\)，我们就有 \\(a ≺ b\\)，换句话说，\\(≺\\) 是局部顺序 \\(\\rightarrow\\) 的线性扩展。然而，如果 \\(a \\rVert b\\)，我们可以有 \\(a ≺ b\\) 或 \\(b ≺ a\\)，所以两个事件的顺序是由算法任意决定的。 比如 \\((1, A)\\) 和 \\((1, C)\\) 两个事件是平行的，按照 Lamport 的算法，\\((1, A)\\) 必然是在 \\((1, C)\\) 之前的，但实际情况可能是 \\((1, C)\\) 在前。\n\\(\\iff\\) is Logical biconditional，当且仅当的意思。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n\\(∨\\) is logical or, \\(∧\\) is logical and.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://luciuschen.github.io/posts/main/20220609201658-lamport_clocks/","summary":"Lamport clocks algorithm on initialisation do \\(t := 0\\) ▻ each node has its own local variable t end on on any event occurring at the local node do \\(t := t + 1\\) end on on request to send message \\(m\\) do \\(t := t + 1\\); send \\((t, m)\\) via the underlying network link end on on receiving \\((t′, m)\\) via the underlying","title":"Lamport clocks"},{"content":"Definition 最弱的广播类型称为先进先出（FIFO）广播。在这个模型中，由同一节点发送的信息按照发送的顺序传递。例如下图中，\\(m_{1}\\) 必须在 \\(m_{3}\\) 之前被传递，因为它们都是由 \\(A\\) 发送的。然而，\\(m_{2}\\) 可以在 \\(m_{1}\\) 和 \\(m_{3}\\) 之前、之间或之后的任何时间被传递。\nFigure 1: FIFO-broadcast\n同一个节点发送的消息必须要按照发送的顺序传递，不同节点发送的消息可以是任意的顺序，比如 \\((m_{2}, m_{1}, m_{3})\\)，\\((m_{1}, m_{2}, m_{3})\\) 或者 \\((m_{1}, m_{3}, m_{2})\\)。\n关于这些广播协议的另一个细节：我们假设每当一个节点广播一个消息时，它也会将该消息传递给自己（在上图中用回环箭头表示）。这在一开始似乎是不必要的，毕竟，一个节点知道它自己广播了什么消息！但是，我们将在 Total order broadcast 中需要这个步骤。\n上图中的执行示例是有效的先进先出「广播」，但它违反了因果性：虽然 \\(B\\) 在接收了 \\(m_{1}\\) 之后才广播的 \\(m_{2}\\)，但节点 \\(C\\) 在 \\(m_{1}\\) 之前就传递了 \\(m_{2}\\)。Causal broadcast 提供了一个比 FIFO broadcast 更严格的排序属性。顾名思义，它确保信息按因果顺序传递：也就是说，如果一条信息的广播发生在另一条信息的广播之前，那么所有节点必须按这个顺序传递这两条信息。如果两个消息是同时广播的，一个节点可以按任何一个顺序传递它们。\nFIFO broadcast algorithm on initialisation do\n\\(sendSeq := 0; delivered := \\langle0, 0, \u0026hellip;, 0\\rangle; buﬀer := {}\\)\nend on\non request to broadcast \\(m\\) at node \\(N_{i}\\) do\nsend \\((i, sendSeq, m)\\) via reliable broadcast\n\\(sendSeq := sendSeq + 1\\)\nend on\non receiving \\(msg\\) from reliable broadcast at node \\(N_{i}\\) do1\n\\(buﬀer := buﬀer ∪ {msg}\\)\nwhile \\(∃sender, m. (sender, delivered[sender], m) ∈ buﬀer\\) do deliver \\(m\\) to the application\n\\(delivered[sender] := delivered[sender] + 1\\)\nend while\nend on\n节点 \\(N_{i}\\) 发送的每个 FIFO broadcast 消息都会附带发送节点编号 \\(i\\) 和一个序列号（该节点发送消息对应的序列号，第一条消息对应为 0，第二条消息对应为 1）。每个节点的本地状态由序列号 \\(sendSeq\\)（计算该节点广播的消息数量）、\\(delivered\\)（一个向量，每个节点有一个条目，统计了每个节点发送消息并传递到该节点的数量）和 \\(buﬀer\\)（一个缓存，用于保留消息直到它们准备好被传递给 Application，也就是 Receiving versus delivering 中提到的 deliver 阶段）组成。该算法检查来自任何发送者的与预期的下一个序列号相匹配的消息，然后递增该序列号，确保来自每个特定发送者的消息按照序列号递增的顺序被传递。\nSummary FIFO broadcast 的保持消息顺序的原理和 Lamport clocks 很相似，都是用递增的整数来确定同一个节点上的消息传递的顺序，\\(deliver\\) 是个存放着所有节点 \\(sendSeq\\) 的向量，存放于每个节点，配合 \\(sendSeq\\) 控制来自同一个节点的消息传递的顺序。\n\\(msg\\) 就是 \\((i, sendSeq, m)\\)\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://luciuschen.github.io/posts/main/20220616105609-fifo_broadcast/","summary":"Definition 最弱的广播类型称为先进先出（FIFO）广播。在这个模型中，由同一节点发送的信息按照发送的顺序传递。例如下图中，\\(m_{1}\\) 必须在 \\(m_{3}\\) 之","title":"FIFO broadcast"},{"content":"Definition Causal broadcast 算法有点类似于 FIFO broadcast：\n每条被广播的消息附上的不是一个序列号，而是一个整数的向量。这种算法有时被称为向量时钟算法，向量时钟算法中，向量元素计算每个节点发生的事件数量，而在 causal broadcast 算法中，向量元素计算来自每个发送者的已发送的消息数量。\n如果节点 \\(C\\) 在 \\(m_{1}\\) 之前收到 \\(m_{2}\\)，\\(C\\) 的广播算法将不得不保留（延迟或缓冲）\\(m_{2}\\)，直到 \\(m_{1}\\) 被传递之后，以确保消息按因果顺序传递​。在下图的例子中，消息 \\(m_{2}\\) 和 \\(m_{3}\\) 是​同时广播​的。节点 \\(A\\) 和 \\(C\\) 按照 \\(m_{1}\\)、\\(m_{3}\\)、\\(m_{2}\\) 的顺序传递消息，而节点 \\(B\\) 按照 \\(m_{1}\\)、\\(m_{2}\\)、\\(m_{3}\\)的顺序传递。这些传递顺序中的任何一个都是可以接受的，因为它们都与因果关系一致。\nFigure 1: causal-broadcast\n有因果关系的信息必须按因果顺序传递。并行的消息可以按照任何顺序传递。\n上图：broadcast(\\(m_{1}\\)) \\(\\longrightarrow\\) broadcast(\\(m_{2}\\)) and broadcast(\\(m_{1}\\)) \\(\\longrightarrow\\) broadcast(\\(m_{2}\\)) and broadcast(\\(m_{1}\\)) broadcast(\\(m_{3}\\)) \\(\\Longrightarrow\\) valid orders are: (\\(m_{1}\\), \\(m_{2}\\), \\(m_{3}\\)) or (\\(m_{1}\\), \\(m_{3}\\), \\(m_{2}\\))\nCausal broadcast algorithm on initialisation do\n\\(sendSeq := 0; delivered := \\langle0, 0, . . ., 0\\rangle; buﬀer := {}\\)\nend on\non request to broadcast \\(m\\) at node \\(N_{i}\\) do\n\\(deps := delivered; deps[i] := sendSeq\\)\nsend (\\(i, deps, m\\)) via reliable broadcast\n\\(sendSeq := sendSeq + 1\\)\nend on\non receiving \\(msg\\) from reliable broadcast at node \\(N_{i}\\) do\n\\(buﬀer := buﬀer ∪ {msg}\\)\nwhile \\(∃(sender, deps, m) ∈ buﬀer. deps ≤ delivered\\) do\ndeliver \\(m\\) to the application\n\\(buﬀer := buﬀer \\ {(sender, deps, m)}\\)1\n\\(delivered[sender] := delivered[sender] + 1\\)\nend while\nend on\n每个节点的本地状态由 \\(sendSeq\\)、\\(delivered\\) 和 \\(buﬀer\\) 组成，它们的含义与 FIFO broadcast 算法中相同。当一个节点想要广播一个消息时，我们会附上发送节点的编号 \\(i\\) 和 \\(deps\\)（表示该消息因果关系的向量）。\\(deps\\) 就是节点本地 \\(delivered\\) 的复制，统计了每个节点发送消息并传递到该节点的数量。在这次广播之前，所有已经在本地交付的消息必须出现在广播消息的因果顺序之前。然后将发送节点自己的这个向量的元素更新为等于 \\(sendSeq\\)，这就​保证了这个节点所广播的每条消息都与同一节点所广播的前一条消息有因果关系​。\n当收到一个消息时，算法首先将其添加到 \\(buﬀer\\) 中，就像 FIFO broadcast 一样，然后在 \\(buﬀer\\) 中搜索任何准备好的消息。比较 \\(deps ≤ delivered\\)。如果这个节点已经交付了所有在因果顺序上必须在这个消息之前的消息，那么，任何在因果关系上准备好的消息都会被传递给 Application，并从 \\(buﬀer\\) 中移除，并且将 \\(delivered\\) 中的相应条目被递增。\nSummary Causal broadcast 的保持因果顺序的原理和 Vector clocks 很相似，向量中的每个条目，前者是消息发送者已发送消息的数量，后者是每个节点发生事件的数量。deps 取代 FIFO broadcast 中的 sendSeq 附带在广播的信息中，这样通过在 Vector clocks 中介绍的向量比较方法，可以确定消息之间的因果关系来控制消息传递的顺序。\n删除 \\(buﬀer\\) 中的 \\({(sender, deps, m)}\\)\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://luciuschen.github.io/posts/main/20220616132407-causal_broadcast/","summary":"Definition Causal broadcast 算法有点类似于 FIFO broadcast： 每条被广播的消息附上的不是一个序列号，而是一个整数的向量。这种算法有时被称为向量时钟算法，向量时钟","title":"Causal broadcast"},{"content":"Given Lamport timestamps \\(L(a)\\) and \\(L(b)\\) with \\(L(a) \u0026lt; L(b)\\)，我们推断不出 \\(a \\rightarrow b\\) 或者 \\(a || b\\).1\n要区分平行的这些事件，需要 vertor clocks:\n假定分布式系统中有 \\(n\\) 个节点，\\(N = \\langle​N_{1}, N_{2}, \u0026hellip;, N_{n}\\rangle\\) 事件 \\(a\\) 的向量时间戳写成 \\(V(a) = \\langle​t_{1}, t_{2}, \u0026hellip;, t_{n}\\rangle\\) \\(t_{i}\\) 是 \\(N_{i}\\) 节点发生时间的数量 每个​节点​都有一个当前的向量时间戳 \\(T\\) 节点 \\(N_{i}\\) 上的事件，向量时间戳 \\(T[i]\\) 递增。 每个消息都附带上向量时间戳 接收者将消息中的向量时间戳合并到本地 除了标量和向量之间的区别之外，向量时钟算法与 Lamport 时钟非常相似。一个节点的向量时钟的初始值是系统中的每个节点的事件数，也就是 0。每当节点 \\(N_{i}\\) 发生事件时，它就会增加其向量钟中的第 \\(i\\) 个条目（它自己的条目）。(In practice, this vector is often implemented as a map from node IDs to integers rather than an array of integers. 在实践中，这里的向量通常是节点 ID 对应 Integer 的 map，而不是 Integer 的数组。)。当一个消息在网络上被发送时，发送者当前的向量时间戳被附加到该消息上。最后，当一个消息被接收时，接收者将消息中的向量时间戳与它的本地时间戳合并，方法是取两个向量的元素的最大值，然后接收者增加它自己的条目。\nVector clocks algorithm on initialisation at node \\(N_{i}\\) do\n\\(T := \\langle0, 0, \u0026hellip;, 0\\rangle\\) ▻ local variable at node \\(N_{i}\\)\nend on\non any event occurring at node \\(N_{i}\\) do\n\\(T[i] = T[i] + 1\\)\nend on\non request to send message \\(m\\) at node Ni do\n\\(T[i] := T[i] + 1\\); send \\((T, m)\\) via network\nend on\non receiving \\((T\u0026rsquo;, m)\\) at node \\(N_{i}\\) via the network do\n\\(T[j] := max(T[j], T\u0026rsquo;[j])\\) for every \\(j \\in {1, \u0026hellip;, n}\\)\n\\(T[i] := T[i] + 1\\); deliver \\(m\\) to the application\nend on\nVector clocks example 假定节点向量是 \\(N = \\langle​A, B, C\\rangle\\):\nFigure 1: vector-example\n事件 \\(e\\) 的向量时间戳是一系列事件的集合， \\(e\\) 和它的因果以来：\\({e} \\cup {a | a \\rightarrow e}\\)2, 3\n比如，\\(\\langle2, 2, 0\\rangle\\)，第一个 2 是表示来自于 \\(A\\) 的两个事件，第二个 2 是表示来自于 \\(B\\) 的两个事件，并且没有来自于 \\(C\\) 的事件。\nVector clocks ordering Define the following order on vector timestamps(in a system with \\(n\\) nodes):\n\\(T = T\u0026rsquo;\\) iff \\(T[i] = T\u0026rsquo;[i]\\) for all \\(i \\in {1, \u0026hellip;, n}\\)4 \\(T \\le T\u0026rsquo;\\) iff \\(T[i] \\le T\u0026rsquo;[i]\\) for all \\( \\in {1, \u0026hellip;, n}\\) \\(T \u0026lt; T\u0026rsquo;\\) iff \\(T \\le T\u0026rsquo;\\) and \\(T \\neq T\u0026rsquo;\\) \\(T || T\u0026rsquo;\\) iff \\(T \u0026gt; T\u0026rsquo;\\) and \\(T\u0026rsquo; \u0026gt; T\\) \\(V(a) \\le V(b)\\) iff \\(({a} \\cup {e | e \\rightarrow a}) ⊆ ({b} \\cup{} {e | e \\rightarrow b})\\)\nProperties of this order:\n\\((V(a) \u0026lt; V(b)) \\iff (a \\rightarrow b)\\) \\((V(a) = V(b)) \\iff (a = b)\\) \\((V(a) \\rVert V(b)) \\iff (a \\rVert b)\\) 然后，我们对向量的时间戳进行部分排序。如果第一个向量的每个元素都小于或等于第二个向量的相应元素，我们就说一个向量小于或等于另一个向量。如果一个向量小于或等于另一个向量，并且它们至少有一个元素是不同的，那么这个向量就严格小于另一个向量。然而，如果一个向量在一个元素中的值较大，而另一个向量在另一个元素中的值较大，那么这两个向量是不可比的。例如，\\(T = \\langle2, 2, 0\\rangle\\) 和 \\(T\u0026rsquo; = \\langle0, 0, 1\\rangle\\) 是不可比的，因为 \\(T[1] \u0026gt; T\u0026rsquo;[1]\\) 但 \\(T[3] \u0026lt; T\u0026rsquo;[3]\\)。\n向量时间戳的部分顺序与发生之前关系所定义的部分顺序完全对应。因此，向量时钟算法为我们提供了一种在实践中计算发生前关系的机制。\n具体参考 Lamport Clocks 中的逻辑双条件。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n\\(\\cup\\) 并集的意思，\\(\\cap\\) 交集的意思。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n集合的描述方法，描述格式为 \\({x | P(x)，x ∈ Ω}\\)。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nif and only if，相当于 \\(\\iff\\)，其 Latex 写作 \\iff​。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://luciuschen.github.io/posts/main/20220602235916-vector_clocks/","summary":"Given Lamport timestamps \\(L(a)\\) and \\(L(b)\\) with \\(L(a) \u0026lt; L(b)\\)，我们推断不出 \\(a \\rightarrow b\\) 或者 \\(a || b\\).1 要区分平行的这些事件，需要 vertor clocks: 假定分布式系统中有 \\(n\\) 个节点，\\(N = \\langle","title":"Vector clocks"},{"content":"Introduction 说起来好笑，我选择 Org-roam 作为自己 PKM 流程最终知识固化的地方，还是因为与之配合的 Org-roam-ui 的美观，随后发现易用性上也很不错。2013年时，第一次接触到 GTD 也是因为 Omnifocus 的美观，为此我还花了 $9.99 买了 iOS 的客户端。\nOrg-roam 是基于 Emacs 平台，对于直接触过 Vim 的我来讲，是个全新的东西，官方是这么形容它的。\nEmacs outshines all other editing software in approximately the same way that the noonday sun does the stars. It is not just bigger and brighter; it simply makes everything else vanish.\n– Neal Stephenson, In the Beginning was the Command Line (1998)\nInstall Emacs With Homebrew First, Doom’s dependencies:\nbrew install git ripgrep brew install coreutils fd xcode-selected --install emacs-mac. It offers good integration with macOS, native emojis and better childframe support.\nbrew tap railwaycat/emacsmacport brew install emacs-mac --with-modules ln -s /usr/local/opt/emacs-mac/Emacs.app /Applications/Emacs.app Doom Doctor 问题 Warning: unable to detect fonts because fontconfig isn\u0026rsquo;t installed\nbrew install fontconfig ! Couldn\u0026rsquo;t find shellcheck. Shell script linting will not work\nbrew install shellcheck Doom Emacs With Emacs and Doom\u0026rsquo;s dependencies installed, next is to install Doom Emacs itself:\ngit clone https://github.com/hlissner/doom-emacs ~/.emacs.d ~/.emacs.d/bin/doom install 如果提示 .emacs.d 已存在，删除重新执行上述命令即可。\n.zshrc 中需要添加 export PATH=\u0026quot;$HOME/.emacs.d/bin:$PATH ，这样就可以直接使用 doom 命令了。\nOrg-roam 具体的配置文件在 .doom.d/ 下，参见 .doom.d。\nShortcuts Shortcuts 功能 备注 C-RET 在当前 headline 所属的内容后建立一个同级 headline 无 headline 时创建一个一级 headline M-RET 在当前 headline 后建立一个同级 headline 同上 M-right 降低当前 headline 的层级 M-left 提高当前 headline 的层级 M-up 将当前 headline 及其内容作为整体向上移动 M-down 将当前 headline 及其内容作为整体向下移动 C-return 在当前列表项的内容后建立一个同级列表项 光标在列表项同一行时有效 M-RET 在当前列表项后建立一个同级列表项 同上 M-right 降低当前列表项的层级 同上 M-left 提高当前列表项的层级 同上 M-up 将当前列表项及其内容作为整体向上移动 同上 M-down 将当前列表项及其内容作为整体向下移动 同上 C-x-o 切换窗口 C-x 中有很多操作，可以看提示。 C-c C-c 在创建 node 编写完毕后快速保存 C-g 取消操作 C-x-d 进入 dired 模式 SPC f r 查找最近文件 C-c C-x C-v 显示图片 Shortcuts 功能 备注 C-c C-s 设置任务开始时间 C-c C-d 设置任务截止时间 C-c C-t 改变任务状态 S-Up/Down 设置任务优先级 [#A], [#B], [#C] C-c C-x C-i 开始任务计时 C-c C-x C-o 终止任务计时 C-c [ 将当前文件加入 Org-Agenda C-c ] 将当前文件从 Org-Agenda 移除 Shortcuts 功能 备注 t 在 Org-Agenda 的任务条目上， 修改任务状态。 C-c C-x C-a 归档 C-c C-w activate refile I 在 Org-Agenda 的任务条目上， 开始计时。 O 在 Org-Agenda 的任务条目上， 终止计时。 z 在任务上添加 note R clock mode, 显示耗时。 C-c C-x C-l 预览 Latex Org grammar basic This is almost anything you need to know about Org mode syntax:\n* This Is A Heading ** This Is A Sub-Heading *** And A Sub-Sub-Heading Paragraphs are separated by at least one empty line. *bold* /italic/ _underlined_ +strikethrough+ =monospaced= [[http://Karl-Voit.at][Link description]] http://Karl-Voit.at → link without description - list item - another item - sub-item 1. also enumerated 2. if you like - [ ] yet to be done - [X] item which is done : Simple pre-formatted text such as for source code. : This also respects the line breaks. *bold* is not bold here. code block myresult = 42 * 23 print(\u0026#39;Hello Europe! \u0026#39; + str(myresult)) table | My Column 1 | My Column 2 | Last Column | |-------------+-------------+-------------| | 42 | foo | bar | | 23 | baz | abcdefg | |-------------+-------------+-------------| | 65 | | | Export Markdown file 这里用的是 ox-pandoc， ~M-x org-pandoc-export-as-gfm~算是我找到最符合 MarkDown 语法的转换了，Emacs 自己的转换会将 Table 转换成 HTML 标签的格式。\nHugo 在文件头部添加\n#+HUGO_BASE_DIR: ~/Dropbox/hugo/ #+HUGO_SECTION: posts/main #+HUGO_WEIGHT: auto #+HUGO_AUTO_SET_LASTMOD: t 需要导出为 \u0026lt;mark\u0026gt;\u0026lt;/mark\u0026gt; 时1\n#+begin_mark marked text #+end_mark 需要导出为块级 \u0026lt;mark\u0026gt;\u0026lt;/mark\u0026gt; 时，也就是前后的空格不进行 trim。\n#+header: :trim-pre nil :trim-post nil #+begin_mark marked text #+end_mark Latex 需要安装 texlive\nbrew install texlive PDF 导出报错 Unicode character 考 (U+8003) not set up for use with LaTeX. 是因为 Latex 本身不支持中文。 Org Special Blocks\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://luciuschen.github.io/posts/main/20220505220832-org_roam/","summary":"Introduction 说起来好笑，我选择 Org-roam 作为自己 PKM 流程最终知识固化的地方，还是因为与之配合的 Org-roam-ui 的美观，随后发现易用性上也很不错。2013年时，第一次接触到 GTD 也","title":"Org-roam"},{"content":"Refactoring Code How To Find Time Complexity Of An Algorithm\nJavaScript Refactoring Tips Refactoring Condition statements Converting callbacks to promises Refactoring Promise chains with async/await Refactoring Code examples Callback Hell ","permalink":"https://luciuschen.github.io/posts/main/20220506193054-refactoring_code/","summary":"Refactoring Code How To Find Time Complexity Of An Algorithm\nJavaScript Refactoring Tips Refactoring Condition statements Converting callbacks to promises Refactoring Promise chains with async/await Refactoring Code examples Callback Hell ","title":"Refactoring Code"},{"content":"重构小程序前端校验接口返参处理 主要是用 Map (ES6+) 处理 if (code){} else if (code){}~，并且利用 ~Promise 封装函数，配合 async 和 await (ES7+)，使得异步操作同步化，抽离出嵌套的逻辑。\n原始代码 // util.js /* 封装wx.request请求 url 接口url params 请求参数 md 请求方式 load 是否显示loading等待框 */ const getResult = function (url, params, md, cb, load, ctype) { //封装wx,request请求 var that = this; if (load) { wx.showLoading({ mask: true, title: \u0026#34;拼命加载中\u0026#34;, }); } var requestParams = { url: ycConfig[ycConfig.env].domain_url + url, data: params, dataType: \u0026#34;json\u0026#34;, method: md ? md : \u0026#34;POST\u0026#34;, header: { \u0026#34;content-type\u0026#34;: ctype || \u0026#34;application/json\u0026#34;, }, success: function (res) { wx.hideLoading(); if (res.data \u0026amp;\u0026amp; res.data.status == \u0026#34;error\u0026#34;) { typeof cb == \u0026#34;function\u0026#34; \u0026amp;\u0026amp; cb(res.data); } else { typeof cb == \u0026#34;function\u0026#34; \u0026amp;\u0026amp; cb(res.data); } }, complete: function (res) {}, fail: function () { wx.hideLoading(); wx.showToast({ title: \u0026#34;网络连接异常\u0026#34;, icon: \u0026#34;none\u0026#34;, }); }, }; wx.request(requestParams); }; module.exports = { getResult, }; // app.js let { getResult } = require(\u0026#34;utils/util.js\u0026#34;); App({ getResult(url, params, md, cb, load, ctype) { var that = this; if (url != \u0026#34;/ffpLogin.pl\u0026#34;) { var userInfo = wx.getStorageSync(\u0026#34;globalUserInfo\u0026#34;); //判断是否有效 if ( isEmpty(userInfo.wechatLoginToken) || isEmpty(userInfo.wechatOpenId) ) { wx.clearStorage(); //清理登录缓存数据 wx.showToast({ title: \u0026#34;登录失效,请重新登录!\u0026#34;, icon: \u0026#34;none\u0026#34;, }); wx.reLaunch({ url: \u0026#34;/pages/login/login\u0026#34;, }); return; } params.wechatLoginToken = userInfo.wechatLoginToken; params.wechatOpenId = userInfo.wechatOpenId; } var dic = {}; dic.cipher = that.encryption(params); function temp_cb(data) { if (data.code == \u0026#34;8888\u0026#34;) { wx.clearStorage(); //清理登录缓存数据 wx.showToast({ title: \u0026#34;登录失效,请重新登录!\u0026#34;, icon: \u0026#34;none\u0026#34;, }); wx.reLaunch({ url: \u0026#34;/pages/login/login\u0026#34;, }); return; } typeof cb == \u0026#34;function\u0026#34; \u0026amp;\u0026amp; cb(data); } getResult(url, dic, md, temp_cb, load, ctype); }, }); Page({ //提交订单 formSubmit: function (formSubmitRes) { var paraDic = { regPhone: this.data.regPhone, shipName: this.data.shipName, customer: this.data.customerName, planType: this.data.planCateID, customerType: this.data.customerID, arriveTime: this.data.isAllMention ? this.data.arrivalTime : \u0026#34;\u0026#34;, takeSite: this.data.isTakeSite ? this.data.takeSiteID : \u0026#34;\u0026#34;, }; var that = this; //提交订单 app.getResult( \u0026#34;/oilPlan/checkInfo.pl\u0026#34;, paraDic, \u0026#34;POST\u0026#34;, function (res) { var appleDetailDic = {}; if (that.data.isTakeSite) { appleDetailDic = { regPhone: that.data.regPhone, planType: that.data.planCateID, customerType: that.data.customerID, siteId: that.data.saleSiteID, shipName: that.data.shipName, customer: formSubmitRes.detail.value.customerName, takeSite: that.data.takeSiteID, planCode: that.data.planCode, pagesType: \u0026#34;0\u0026#34;, //type 0 新增，1 修改 isAgain: \u0026#34;1\u0026#34;, //修改识别 shipLength: formSubmitRes.detail.value.shipLength, //船舶 shipType: that.data.shipTypeSelect, //船舶类型 shipLoad: that.data.shipLoadSelect, //载重 isAllMention: that.data.isAllMention, nineyards: formSubmitRes.detail.value.nineyards, //九位码 arrivalTime: that.data.arrivalTime, //预计到站时间 otherPhone: formSubmitRes.detail.value.otherPhone, }; } else { appleDetailDic = { regPhone: that.data.regPhone, planType: that.data.planCateID, customerType: that.data.customerID, siteId: that.data.saleSiteID, shipName: that.data.shipName, customer: formSubmitRes.detail.value.customerName, takeSite: \u0026#34;\u0026#34;, planCode: that.data.planCode, pagesType: \u0026#34;0\u0026#34;, //type 0 新增，1 修改 isAgain: \u0026#34;1\u0026#34;, //修改识别 shipLength: formSubmitRes.detail.value.shipLength, //船舶 shipType: that.data.shipTypeSelect, //船舶类型 shipLoad: that.data.shipLoadSelect, //载重 isAllMention: that.data.isAllMention, nineyards: formSubmitRes.detail.value.nineyards, //九位码 arrivalTime: that.data.arrivalTime, //预计到站时间 otherPhone: formSubmitRes.detail.value.otherPhone, }; } if (res.code == \u0026#34;0000\u0026#34;) { //判断是否修改 if (that.data.isDataChange) { //修改 wx.navigateTo({ url: \u0026#34;/pages/plan/applyDetail/applyDetail?appleDetailDic=\u0026#34; + JSON.stringify(appleDetailDic), }); } else { //再来一单的申请详情页 wx.navigateTo({ url: \u0026#34;/pages/plan/planAgain-detail/planAgain-detail?appleDetailDic=\u0026#34; + JSON.stringify(appleDetailDic), }); } } else if (res.code == \u0026#34;0003\u0026#34;) { wx.showModal({ title: \u0026#34;提示\u0026#34;, content: res.msg, success(res) { if (res.confirm) { //创建新船 app.getResult( \u0026#34;/oilPlan/addShip.pl\u0026#34;, paraDic, \u0026#34;POST\u0026#34;, function (res) { if (res.code == \u0026#34;0000\u0026#34;) { if (appleDetailDic.customerType != 3) { app.getResult( \u0026#34;/oilPlan/checkInfo.pl\u0026#34;, paraDic, \u0026#34;POST\u0026#34;, function (res) { if (res.code == \u0026#34;0000\u0026#34;) { //判断是否修改 if (that.data.isDataChange) { //修改 wx.navigateTo({ url: \u0026#34;/pages/plan/applyDetail/applyDetail?appleDetailDic=\u0026#34; + JSON.stringify(appleDetailDic), }); } else { //再来一单的申请详情页 wx.navigateTo({ url: \u0026#34;/pages/plan/planAgain-detail/planAgain-detail?appleDetailDic=\u0026#34; + JSON.stringify(appleDetailDic), }); } } else if (res.code == \u0026#34;0010\u0026#34;) { //点击弹框 wx.showModal({ title: \u0026#34;提示\u0026#34;, content: res.msg, confirmText: \u0026#34;确定\u0026#34;, cancelText: \u0026#34;取消\u0026#34;, success(res) { if (res.confirm) { //判断是否修改 debugger; if (that.data.isDataChange) { //修改 wx.navigateTo({ url: \u0026#34;/pages/plan/applyDetail/applyDetail?appleDetailDic=\u0026#34; + JSON.stringify(appleDetailDic), }); } else { //再来一单的申请详情页 wx.navigateTo({ url: \u0026#34;/pages/plan/planAgain-detail/planAgain-detail?appleDetailDic=\u0026#34; + JSON.stringify(appleDetailDic), }); } } else if (res.cancel) { } }, }); } else { wx.showToast({ title: res.msg, icon: \u0026#34;none\u0026#34;, }); } }, \u0026#34;ture\u0026#34; ); } else { if (that.data.isDataChange) { //修改 wx.navigateTo({ url: \u0026#34;/pages/plan/applyDetail/applyDetail?appleDetailDic=\u0026#34; + JSON.stringify(appleDetailDic), }); } else { //再来一单的申请详情页 wx.navigateTo({ url: \u0026#34;/pages/plan/planAgain-detail/planAgain-detail?appleDetailDic=\u0026#34; + JSON.stringify(appleDetailDic), }); } } } else { wx.showToast({ title: res.msg, icon: \u0026#34;none\u0026#34;, }); } }, \u0026#34;ture\u0026#34; ); } else if (res.cancel) { } }, }); } else if (res.code == \u0026#34;0008\u0026#34;) { //点击弹框 wx.showModal({ title: \u0026#34;提示\u0026#34;, content: res.msg, confirmText: \u0026#34;仍然选择\u0026#34;, cancelText: \u0026#34;重新选择\u0026#34;, success(res) { if (res.confirm) { paraDic.ignore = 1; app.getResult( \u0026#34;/oilPlan/checkInfo.pl\u0026#34;, paraDic, \u0026#34;POST\u0026#34;, function (res) { if (res.code == \u0026#34;0000\u0026#34;) { if (that.data.isDataChange) { //修改 wx.navigateTo({ url: \u0026#34;/pages/plan/applyDetail/applyDetail?appleDetailDic=\u0026#34; + JSON.stringify(appleDetailDic), }); } else { //再来一单的申请详情页 wx.navigateTo({ url: \u0026#34;/pages/plan/planAgain-detail/planAgain-detail?appleDetailDic=\u0026#34; + JSON.stringify(appleDetailDic), }); } } else if (res.code == \u0026#34;0010\u0026#34;) { //点击弹框 wx.showModal({ title: \u0026#34;提示\u0026#34;, content: res.msg, confirmText: \u0026#34;确定\u0026#34;, cancelText: \u0026#34;取消\u0026#34;, success(res) { if (res.confirm) { //判断是否修改 if (that.data.isDataChange) { //修改 wx.navigateTo({ url: \u0026#34;/pages/plan/applyDetail/applyDetail?appleDetailDic=\u0026#34; + JSON.stringify(appleDetailDic), }); } else { //再来一单的申请详情页 wx.navigateTo({ url: \u0026#34;/pages/plan/planAgain-detail/planAgain-detail?appleDetailDic=\u0026#34; + JSON.stringify(appleDetailDic), }); } } else if (res.cancel) { } }, }); } else if (res.code == \u0026#34;0003\u0026#34;) { wx.showModal({ title: \u0026#34;提示\u0026#34;, content: res.msg, success(res) { if (res.confirm) { var paraDic = { shipName: that.data.shipName, customer: that.data.customerName, customerType: that.data.customerID, }; //创建新船 app.getResult( \u0026#34;/oilPlan/addShip.pl\u0026#34;, paraDic, \u0026#34;POST\u0026#34;, function (res) { if (res.code == \u0026#34;0000\u0026#34;) { if (appleDetailDic.customerType != 3) { var paraDic = { regPhone: appleDetailDic.regPhone, shipName: appleDetailDic.shipName, customer: appleDetailDic.customer, planType: appleDetailDic.planType, customerType: appleDetailDic.customerType, arriveTime: appleDetailDic.arriveTime, takeSite: appleDetailDic.takeSite, }; app.getResult( \u0026#34;/oilPlan/checkInfo.pl\u0026#34;, paraDic, \u0026#34;POST\u0026#34;, function (res) { if (res.code == \u0026#34;0000\u0026#34;) { //判断是否修改 if (that.data.isDataChange) { //修改 wx.navigateTo({ url: \u0026#34;/pages/plan/applyDetail/applyDetail?appleDetailDic=\u0026#34; + JSON.stringify(appleDetailDic), }); } else { //再来一单的申请详情页 wx.navigateTo({ url: \u0026#34;/pages/plan/planAgain-detail/planAgain-detail?appleDetailDic=\u0026#34; + JSON.stringify(appleDetailDic), }); } } else if (res.code == \u0026#34;0010\u0026#34;) { //点击弹框 wx.showModal({ title: \u0026#34;提示\u0026#34;, content: res.msg, confirmText: \u0026#34;确定\u0026#34;, cancelText: \u0026#34;取消\u0026#34;, success(res) { if (res.confirm) { //判断是否修改 debugger; if (that.data.isDataChange) { //修改 wx.navigateTo({ url: \u0026#34;/pages/plan/applyDetail/applyDetail?appleDetailDic=\u0026#34; + JSON.stringify( appleDetailDic ), }); } else { //再来一单的申请详情页 wx.navigateTo({ url: \u0026#34;/pages/plan/planAgain-detail/planAgain-detail?appleDetailDic=\u0026#34; + JSON.stringify( appleDetailDic ), }); } } else if (res.cancel) { } }, }); } else { wx.showToast({ title: res.msg, icon: \u0026#34;none\u0026#34;, }); } }, \u0026#34;ture\u0026#34; ); } else { if (that.data.isDataChange) { //修改 wx.navigateTo({ url: \u0026#34;/pages/plan/applyDetail/applyDetail?appleDetailDic=\u0026#34; + JSON.stringify(appleDetailDic), }); } else { //再来一单的申请详情页 wx.navigateTo({ url: \u0026#34;/pages/plan/planAgain-detail/planAgain-detail?appleDetailDic=\u0026#34; + JSON.stringify(appleDetailDic), }); } } } else { wx.showToast({ title: res.msg, icon: \u0026#34;none\u0026#34;, }); } }, \u0026#34;ture\u0026#34; ); } else if (res.cancel) { } }, }); } else { wx.showToast({ title: res.msg, icon: \u0026#34;none\u0026#34;, }); } }, \u0026#34;ture\u0026#34; ); } else if (res.cancel) { } }, }); } else if (res.code == \u0026#34;0010\u0026#34;) { //点击弹框 wx.showModal({ title: \u0026#34;提示\u0026#34;, content: res.msg, confirmText: \u0026#34;确定\u0026#34;, cancelText: \u0026#34;取消\u0026#34;, success(res) { if (res.confirm) { //判断是否修改 debugger; if (that.data.isDataChange) { //修改 wx.navigateTo({ url: \u0026#34;/pages/plan/applyDetail/applyDetail?appleDetailDic=\u0026#34; + JSON.stringify(appleDetailDic), }); } else { //再来一单的申请详情页 wx.navigateTo({ url: \u0026#34;/pages/plan/planAgain-detail/planAgain-detail?appleDetailDic=\u0026#34; + JSON.stringify(appleDetailDic), }); } } else if (res.cancel) { } }, }); } else { wx.showToast({ title: res.msg, icon: \u0026#34;none\u0026#34;, }); } }, \u0026#34;ture\u0026#34; ); }, }); 重构后的代码 // util.js // 封装 wx.request() 返回 Promise const wxRequest = (url, params, md, load, ctype) =\u0026gt; { if (load) { wx.showLoading({ mask: true, title: \u0026#34;拼命加载中\u0026#34;, }); } let taskController; let task = new Promise((resolve, reject) =\u0026gt; { taskController = wx.request({ url: ycConfig[ycConfig.env].domain_url + url, data: params, dataType: \u0026#34;json\u0026#34;, method: md ? md : \u0026#34;POST\u0026#34;, header: { \u0026#34;content-type\u0026#34;: ctype || \u0026#34;application/json\u0026#34;, }, success: (res) =\u0026gt; { wx.hideLoading(); resolve(res); }, fail: (err) =\u0026gt; { reject(() =\u0026gt; { wx.hideLoading(); wx.showToast({ title: \u0026#34;网络连接异常\u0026#34;, icon: \u0026#34;none\u0026#34;, }); }); }, }); }); return { task, taskController }; }; module.exports = { getResult, }; // app.js let { getResult, } = require(\u0026#34;utils/util.js\u0026#34;); App({ getRequest(url, params, md, load, ctype) { var that = this; if (url != \u0026#34;/ffpLogin.pl\u0026#34;) { var userInfo = wx.getStorageSync(\u0026#34;globalUserInfo\u0026#34;); //判断是否有效 if ( isEmpty(userInfo.wechatLoginToken) || isEmpty(userInfo.wechatOpenId) ) { wx.clearStorage(); //清理登录缓存数据 wx.showToast({ title: \u0026#34;登录失效,请重新登录!\u0026#34;, icon: \u0026#34;none\u0026#34;, }); wx.reLaunch({ url: \u0026#34;/pages/login/login\u0026#34;, }); return; } params.wechatLoginToken = userInfo.wechatLoginToken; params.wechatOpenId = userInfo.wechatOpenId; } var dic = {}; dic.cipher = that.encryption(params); return new Promise((resolve, reject) =\u0026gt; { getRequest(url, dic, md, load, ctype).task.then((res) =\u0026gt; { if (res.code == \u0026#34;8888\u0026#34;) { wx.clearStorage(); //清理登录缓存数据 wx.showToast({ title: \u0026#34;登录失效,请重新登录!\u0026#34;, icon: \u0026#34;none\u0026#34;, }); wx.reLaunch({ url: \u0026#34;/pages/login/login\u0026#34;, }); return; } else { resolve(res); } }); }); } // 业务代码 Page({ checkInfo: (paraDic) =\u0026gt; { return app.getRequest(\u0026#34;/oilPlan/checkInfo.pl\u0026#34;, paraDic, \u0026#34;POST\u0026#34;, \u0026#34;ture\u0026#34;); }, addShip: (paraDic) =\u0026gt; { return app.getRequest(\u0026#34;/oilPlan/addShip.pl\u0026#34;, paraDic, \u0026#34;POST\u0026#34;, \u0026#34;ture\u0026#34;); }, innerRouter: function (isDataChange, appleDetailDic) { if (isDataChange) { //修改 wx.navigateTo({ url: \u0026#34;/pages/plan/applyDetail/applyDetail?appleDetailDic=\u0026#34; + JSON.stringify(appleDetailDic), }); } else { //再来一单的申请详情页 wx.navigateTo({ url: \u0026#34;/pages/plan/planAgain-detail/planAgain-detail?appleDetailDic=\u0026#34; + JSON.stringify(appleDetailDic), }); } }, //提交订单 formSubmit: function (formSubmitRes) { var paraDic = { regPhone: this.data.regPhone, shipName: this.data.shipName, customer: this.data.customerName, planType: this.data.planCateID, customerType: this.data.customerID, arriveTime: this.data.isAllMention ? this.data.arrivalTime : \u0026#34;\u0026#34;, takeSite: this.data.isTakeSite ? this.data.takeSiteID : \u0026#34;\u0026#34;, }; var that = this; var appleDetailDic = {}; if (that.data.isTakeSite) { appleDetailDic = { regPhone: that.data.regPhone, planType: that.data.planCateID, customerType: that.data.customerID, siteId: that.data.saleSiteID, shipName: that.data.shipName, customer: formSubmitRes.detail.value.customerName, takeSite: that.data.takeSiteID, planCode: that.data.planCode, pagesType: \u0026#34;0\u0026#34;, //type 0 新增，1 修改 isAgain: \u0026#34;1\u0026#34;, //修改识别 shipLength: formSubmitRes.detail.value.shipLength, //船舶 shipType: that.data.shipTypeSelect, //船舶类型 shipLoad: that.data.shipLoadSelect, //载重 isAllMention: that.data.isAllMention, nineyards: formSubmitRes.detail.value.nineyards, //九位码 arrivalTime: that.data.arrivalTime, //预计到站时间 otherPhone: formSubmitRes.detail.value.otherPhone, }; } else { appleDetailDic = { regPhone: that.data.regPhone, planType: that.data.planCateID, customerType: that.data.customerID, siteId: that.data.saleSiteID, shipName: that.data.shipName, customer: formSubmitRes.detail.value.customerName, takeSite: \u0026#34;\u0026#34;, planCode: that.data.planCode, pagesType: \u0026#34;0\u0026#34;, //type 0 新增，1 修改 isAgain: \u0026#34;1\u0026#34;, //修改识别 shipLength: formSubmitRes.detail.value.shipLength, //船舶 shipType: that.data.shipTypeSelect, //船舶类型 shipLoad: that.data.shipLoadSelect, //载重 isAllMention: that.data.isAllMention, nineyards: formSubmitRes.detail.value.nineyards, //九位码 arrivalTime: that.data.arrivalTime, //预计到站时间 otherPhone: formSubmitRes.detail.value.otherPhone, }; } const statusCode = new Map([ [ \u0026#34;0000\u0026#34;, (msg, options) =\u0026gt; { // 跳转新页面 that.innerRouter(options.isDataChange, options.appleDetailDic); }, ], [ \u0026#34;0001\u0026#34;, (msg, options) =\u0026gt; { wx.showToast({ title: msg, icon: \u0026#34;none\u0026#34;, }); }, ], [ \u0026#34;0003\u0026#34;, async (msg, options) =\u0026gt; { // wx.showModal(Object object) 支持 Promise 风格调用 const modalResult = await wx.showModal({ title: \u0026#34;提示\u0026#34;, content: msg, }); if (modalResult.confirm) { await that.addShip(options.paraDic); showMessage(await that.checkInfo(options.paraDic), options); } }, ], [ \u0026#34;0008\u0026#34;, async (msg, options) =\u0026gt; { const modalResult = await wx.showModal({ title: \u0026#34;提示\u0026#34;, content: msg, }); if (modalResult.confirm) { options.paraDic.ignore = 1; showMessage(await that.checkInfo(options.paraDic), options); } }, ], [ \u0026#34;0010\u0026#34;, async (msg, options) =\u0026gt; { const modalResult = await wx.showModal({ title: \u0026#34;提示\u0026#34;, content: msg, }); if (modalResult.confirm) { // 跳转新页面 that.innerRouter(options.isDataChange, options.appleDetailDic); } }, ], ]); // 除仅提示外的后端 code const showToastArr = [\u0026#34;0000\u0026#34;, \u0026#34;0008\u0026#34;, \u0026#34;0003\u0026#34;, \u0026#34;0010\u0026#34;]; // 根据请求后台得到的 code 处理不同逻辑 const showMessage = (res, options) =\u0026gt; { const code = res.data.code; [...statusCode].map(([key, value]) =\u0026gt; { key === (!showToastArr.includes(code) ? \u0026#34;0001\u0026#34; : code) ? value.call(this, res.data.msg, options) : \u0026#34;\u0026#34;; }); }; (async () =\u0026gt; { const options = {}; options.appleDetailDic = appleDetailDic; options.isDataChange = that.data.isDataChange; options.paraDic = paraDic; showMessage(await that.checkInfo(paraDic), options); })(); }, }); ","permalink":"https://luciuschen.github.io/posts/main/20220616092944-callback_hell/","summary":"重构小程序前端校验接口返参处理 主要是用 Map (ES6+) 处理 if (code){} else if (code){}~，并且利用 ~Promise 封装函数，配合 async 和 await (ES7+)，使得异步操作同步化，抽","title":"Callback Hell"},{"content":"Misc Templatemaker\n制作各种纸盒的教程，可以选择对应的例子下载剪裁的 PDF。\nWriting WeChat Markdown Editor\n一款高度简洁的微信 Markdown 编辑器：支持 Markdown 语法、色盘取色、多图上传、一键下载文档、自定义 CSS 样式、一键重置等特性。\n查找 citations 的网站 zoterobib\nYour bibliography is empty. To add a source, paste or type its URL, ISBN, DOI, PMID, arXiv ID, or title into the search box above\ndoi2bib\ngive us a DOI and we will do our best to get you the BibTeX entry\nBibSonomy\nThe easy way to manage scientific publications and bookmarks\nBibSonomy helps you to manage your publications and bookmarks, to collaborate with your colleagues and to find new interesting material for your research.\nBibTeX Search\nYou\u0026rsquo;re searching over millions of BibTeX records\u0026hellip;\nGoogle Scholar\n站在巨人的肩膀上\nBook For books I usually use a site, where it is possible to get Bibtex citations from Amazon.com articles. This is very good for books, and some inproceedings and incollections might be found here as well.\nAmazon Article As a Software Engineer I quite often have to deal with technical papers from ACM or IEEE. Both their catalogs provide Bibtex export capabilities.\nACM\nIEEE Xplore\nAdvancing Technology for Humanity\nBook Library Genesis\n电子书资源查找，中英文都有，英文相对较多。\nVideo BBC Sound effects\nBBC 提供的免费下载的音效的网站。\nMedicine 默沙东诊疗手册\n顾名思义，权威的诊疗查询手册。\nDesign 日本の伝統色\n日本的一个颜色拾取网站，很漂亮。\nChrome extension Language Reactor\n提供 NetFlix、Youtube、TurtleTube、Video File、Text 的翻译，以及 Flashcards。\nFront-End codepen\nThe best place to build, test, and discover front-end code\n","permalink":"https://luciuschen.github.io/posts/main/20220506185941-tools_to_increase_productivity_and_efficiency/","summary":"Misc Templatemaker 制作各种纸盒的教程，可以选择对应的例子下载剪裁的 PDF。 Writing WeChat Markdown Editor 一款高度简洁的微信 Markdown 编辑器：支持 Markdown 语法、色盘取色、多图上传、一键下载文档","title":"Tools to Increase Productivity and Efficiency"},{"content":"Troubleshoot Issues in MySQL\nSort Chinese text fields alphabetically by first letter\n","permalink":"https://luciuschen.github.io/posts/main/20220530185321-mysql/","summary":"Troubleshoot Issues in MySQL\nSort Chinese text fields alphabetically by first letter","title":"MySQL"},{"content":"这里用 setTimeout() 模仿异步请求。\nconst callbackFn = (firstName, callback) =\u0026gt; { setTimeout(() =\u0026gt; { if (!firstName) return callback(new Error(\u0026#34;no first name passed in!\u0026#34;)); // failed const fullName = `${firstName} Doe`; return callback(fullName); // succeed }, 2000); }; callbackFn(\u0026#34;John\u0026#34;, console.log); callbackFn(null, console.log); Promise 实现如下\nconst promiseFn = (firstName) =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { if (!firstName) reject(new Error(\u0026#34;no first name passed in!\u0026#34;)); // failed const fullName = `${firstName} Doe`; resolve(fullName); // succeed }, 2000); }); }; promiseFn(\u0026#34;Jane\u0026#34;).then(console.log); promiseFn().catch(console.log); 这里是 Promise 一些需要注意的点\nconst setDelay = (millisecond) =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { if (typeof millisecond != \u0026#34;number\u0026#34;) reject(new Error(\u0026#34;参数必须是number类型\u0026#34;)); setTimeout(() =\u0026gt; { resolve(`我延迟了${millisecond}毫秒后输出的`); }, millisecond); }); }; const setDelaySecond = (seconds) =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { if (typeof seconds != \u0026#34;number\u0026#34; || seconds \u0026gt; 10) reject(new Error(\u0026#34;参数必须是number类型，并且小于等于10\u0026#34;)); setTimeout(() =\u0026gt; { resolve(`我延迟了${seconds}秒后输出的，是第二个函数`); }, seconds * 1000); }); }; // Promise chains // then 式链式写法的本质其实是一直往下传递返回一个新的 Promise，也就是说 then 在下一步接收的是上一步返回的 Promise。 // 处理错误只需要在链式末尾 catch 进行处理就可以。 setDelay(2000) .then((result) =\u0026gt; { console.log(result); console.log(\u0026#34;我进行到第一步的\u0026#34;); return setDelaySecond(3); }) .then((result) =\u0026gt; { console.log(\u0026#34;我进行到第二步的\u0026#34;); console.log(result); }) .catch((err) =\u0026gt; { console.log(err); }); // Promise 中间返回自定义的值只需要用 `retunPromise.resolve()` 处理就可以。 setDelay(2000) .then((result) =\u0026gt; { console.log(\u0026#34;第一步完成了\u0026#34;); console.log(result); let message = \u0026#34;这是我自己想处理的值\u0026#34;; return Promise.resolve(message); // 这里返回我想在下一阶段处理的值 }) .then((result) =\u0026gt; { console.log(\u0026#34;第二步完成了\u0026#34;); console.log(result); // 这里拿到上一阶段的返回值 //return Promise.resolve(\u0026#39;这里可以继续返回\u0026#39;) }) .catch((err) =\u0026gt; { console.log(err); }); ","permalink":"https://luciuschen.github.io/posts/main/20220506193545-converting_callbacks_to_promises/","summary":"这里用 setTimeout() 模仿异步请求。 const callbackFn = (firstName, callback) =\u0026gt; { setTimeout(() =\u0026gt; { if (!firstName) return callback(new Error(\u0026#34;no first name passed in!\u0026#34;)); // failed const fullName = `${firstName} Doe`; return callback(fullName); // succeed }, 2000); }; callbackFn(\u0026#34;John\u0026#34;, console.log); callbackFn(null, console.log); Promise 实现如下 const promiseFn = (firstName) =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { if (!firstName)","title":"Converting callbacks to promises"},{"content":"const setDelay = (millisecond) =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { if (typeof millisecond != \u0026#34;number\u0026#34;) reject(new Error(\u0026#34;参数必须是number类型\u0026#34;)); setTimeout(() =\u0026gt; { resolve(`我延迟了${millisecond}毫秒后输出的`); }, millisecond); }); }; const setDelaySecond = (seconds) =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { if (typeof seconds != \u0026#34;number\u0026#34; || seconds \u0026gt; 10) reject(new Error(\u0026#34;参数必须是number类型，并且小于等于10\u0026#34;)); setTimeout(() =\u0026gt; { resolve(`我延迟了${seconds}秒后输出的，注意单位是秒`); }, seconds * 1000); }); }; // Promise chains setDelay(1000) .then((result) =\u0026gt; { console.log(result); return setDelaySecond(2); }) .then((result) =\u0026gt; { console.log(result); return setDelay(1000); }) .then((result) =\u0026gt; { console.log(result); console.log(\u0026#34;完成\u0026#34;); }) .catch((err) =\u0026gt; { console.log(err); }); // async/await (async () =\u0026gt; { const result = await setDelay(1000); console.log(result); console.log(await setDelaySecond(2)); console.log(await setDelay(1000)); console.log(\u0026#34;完成了\u0026#34;); })(); await 是个运算符，用于组成表达式，~await~ 表达式的运算结果取决于它等的东西。\n如果等到的不是个 Promise 对象，那么 await 表达式的运算结果就等于它等到的东西。\n如果等到的是个 Promise 对象，那么 await 就会阻塞后面的代码，等着 Promise 对象的 resolved 状态，然后得到 resolve 的值，作为 await 表达式的运算结果。\n","permalink":"https://luciuschen.github.io/posts/main/20220506193624-refactoring_promise_chains_with_async_await/","summary":"const setDelay = (millisecond) =\u0026gt; { return new Promise((resolve, reject) =\u0026gt; { if (typeof millisecond != \u0026#34;number\u0026#34;) reject(new Error(\u0026#34;参数必须是number类型\u0026#34;)); setTimeout(() =\u0026gt; { resolve(`我延迟了${mi","title":"Refactoring Promise chains with async/await"},{"content":"前端网络请求回调中经常会根据后端返回的不同 code 进行不同的业务处理。\nif (res.data.code === \u0026#34;0000\u0026#34;) { //do something } else if (res.data.code === \u0026#34;0001\u0026#34;) { //do something } else if (res.data.code === \u0026#34;0002\u0026#34;) { //do something } else { //do something } 简单应用\nconst statusCode = new Map([ [\u0026#34;0000\u0026#34;, \u0026#34;请求成功\u0026#34;], [\u0026#34;0001\u0026#34;, \u0026#34;未授权\u0026#34;], [\u0026#34;0002\u0026#34;, \u0026#34;拒绝访问\u0026#34;], ]); statusCode.get(0001); 复杂业务函数处理\nconst getRequest = (params) =\u0026gt; { console.log(\u0026#34;请求打印\u0026#34;); }; const statusCode = new Map([ [ \u0026#34;0000\u0026#34;, async (params) =\u0026gt; { console.log(getRequest(params)); }, ], [ \u0026#34;0001\u0026#34;, (params) =\u0026gt; { console.log(\u0026#34;未授权\u0026#34;); }, ], [ \u0026#34;0002\u0026#34;, (params) =\u0026gt; { console.log(\u0026#34;拒绝访问\u0026#34;); }, ], ]); const params = {}; const showMessage = (code) =\u0026gt; { // Map 对象转数组 [...statusCode].forEach(([key, value]) =\u0026gt; { key === code ? value.call(params) : \u0026#34;\u0026#34;; }); }; showMessage(\u0026#34;0000\u0026#34;); // 未授权 forEach() 和 map() 的区别：\nforEach() 会修改原来的数组，而 map() 会得到一个新的数组并返回。所以需要生成新数组的时候，就用后者, 否则就用前者。 Map vs Object\nAccording to MDN:\nA Map object can iterate its elements in insertion order - a for..of loop will return an array of [key, value] for each iteration.\nObjects are similar to Maps in that both let you set keys to values, retrieve those values, delete keys, and detect whether something is stored at a key. Because of this, Objects have been used as Maps historically; however, there are important differences between Objects and Maps that make using a Map better.\nAn Object has a prototype, so there are default keys in the map. However, this can be bypassed using map = Object.create(null). The keys of an Object are Strings, where they can be any value for a Map. You can get the size of a Map easily while you have to manually keep track of size for an Object.\n","permalink":"https://luciuschen.github.io/posts/main/20220506193520-refactoring_condition_statements/","summary":"前端网络请求回调中经常会根据后端返回的不同 code 进行不同的业务处理。 if (res.data.code === \u0026#34;0000\u0026#34;) { //do something } else if (res.data.code === \u0026#34;0001\u0026#34;) { //do something } else if (res.data.code === \u0026#34;0002\u0026#34;) { //do something } else { //do something } 简单应用 const statusCode =","title":"Refactoring Condition statements"},{"content":"The most common metric for calculating time complexity is Big O notation. This removes all constant factors so that the running time can be estimated in relation to N as N approaches infinity. In general you can think of it like this:\nstatement; Is constant. The running time of the statement will not change in relation to N.\nfor (i = 0; i \u0026lt; N; i++) statement; Is linear. The running time of the loop is directly proportional to N. When N doubles, so does the running time.\nfor (i = 0; i \u0026lt; N; i++) { for (j = 0; j \u0026lt; N; j++) statement; } Is quadratic. The running time of the two loops is proportional to the square of N. When N doubles, the running time increases by N * N.\nwhile (low \u0026lt;= high) { mid = (low + high) / 2; if (target \u0026lt; list[mid]) high = mid - 1; else if (target \u0026gt; list[mid]) low = mid + 1; else break; } Is logarithmic. The running time of the algorithm is proportional to the number of times N can be divided by 2. This is because the algorithm divides the working area in half with each iteration.\nvoid quicksort ( int list[], int left, int right ){ int pivot = partition ( list, left, right ); quicksort ( list, left, pivot - 1 ); quicksort ( list, pivot + 1, right ); } Is N * log ( N ). The running time consists of N loops (iterative or recursive) that are logarithmic, thus the algorithm is a combination of linear and logarithmic.\nIn general, doing something with every item in one dimension is linear, doing something with every item in two dimensions is quadratic, and dividing the working area in half is logarithmic. There are other Big O measures such as cubic, exponential, and square root, but they\u0026rsquo;re not nearly as common. Big O notation is described as O ( ) where is the measure. The quicksort algorithm would be described as O ( N * log ( N ) ).\nNote that none of this has taken into account best, average, and worst case measures. Each would have its own Big O notation. Also note that this is a VERY simplistic explanation. Big O is the most common, but it\u0026rsquo;s also more complex that I\u0026rsquo;ve shown. There are also other notations such as big omega, little o, and big theta. You probably won\u0026rsquo;t encounter them outside of an algorithm analysis course. ;)\n","permalink":"https://luciuschen.github.io/posts/main/20220506193205-how_to_find_time_complexity_of_an_algorithm/","summary":"The most common metric for calculating time complexity is Big O notation. This removes all constant factors so that the running time can be estimated in relation to N as N approaches infinity. In general you can think of it like this:\nstatement; Is constant. The running time of the statement will not change in relation to N.\nfor (i = 0; i \u0026lt; N; i++) statement; Is linear. The running time of the loop is directly proportional to N.","title":"How To Find Time Complexity Of An Algorithm"},{"content":"UTF8 default Proofing set is Utf8_general_ci, it is not in Chinese. You need to force MySQL to sort by Chinese.\nselect * FROM MyTable ORDER by CONVERT (Chinesecolumnname USING GBK) COLLATE gbk_chinese_ci; 为了达到更快更效率的查询，需要另外再建立一个索引列，并在索引列中插入标签字第一个字母或者是拼音。\n","permalink":"https://luciuschen.github.io/posts/main/20220601104443-sort_chinese_text_fields_alphabetically_by_first_letter/","summary":"UTF8 default Proofing set is Utf8_general_ci, it is not in Chinese. You need to force MySQL to sort by Chinese. select * FROM MyTable ORDER by CONVERT (Chinesecolumnname USING GBK) COLLATE gbk_chinese_ci; 为了达到更快更效率的查询，需要另外再建立一个索引列，并在索引列中插入标签字第","title":"Sort Chinese text fields alphabetically by first letter"},{"content":"Mysql 无法更新表 查询是否有锁表。\nSHOW OPEN TABLES WHERE In_use \u0026gt; 0; 查询是否有正在执行的事务\nSELECT * FROM INFORMATION_SCHEMA.INNODB_TRX; ","permalink":"https://luciuschen.github.io/posts/main/20220530180443-troubleshoot_issues_in_mysql/","summary":"Mysql 无法更新表 查询是否有锁表。 SHOW OPEN TABLES WHERE In_use \u0026gt; 0; 查询是否有正在执行的事务 SELECT * FROM INFORMATION_SCHEMA.INNODB_TRX;","title":"Troubleshoot Issues in MySQL"},{"content":"Hardware HHKB Logitech MX Master 3 for Mac 17 MBP DELL U2417H Bose QC 35/NFAUDIO 二单元娄氏动铁 NF2u Software Git Git Skills Design Tools Figma Excalidraw Pinboard Tools to Increase Productivity and Efficiency HammerSpoon Karabiner-Elements VSCode Squirrel ","permalink":"https://luciuschen.github.io/posts/main/20220508195206-personal_knowledge_wiki/","summary":"Hardware HHKB Logitech MX Master 3 for Mac 17 MBP DELL U2417H Bose QC 35/NFAUDIO 二单元娄氏动铁 NF2u Software Git Git Skills Design Tools Figma Excalidraw Pinboard Tools to Increase Productivity and Efficiency HammerSpoon Karabiner-Elements VSCode Squirrel","title":"Personal Knowledge Wiki"},{"content":"","permalink":"https://luciuschen.github.io/posts/main/20220520185239-hammerspoon/","summary":"","title":"HammerSpoon"},{"content":"删除以往的提交记录\ngit checkout --orphan latest_branch git add -A git commit -am \u0026#34;commit message\u0026#34; git branch -D main git branch -m main git push -f origin main 发现上次提交的内容有误，需要再次修改，但不想重复提交，而是合并到上一次提交中，并且不更新提交 comment。\ngit commit --amend --no-edit --amend: 修改最新的一次 commit，将这次的 stage change 直接添加到上一次 commit 中。 --no-edit: 不修改上一次 commit 的 comment，直接使用上一次的 comment。 如果需要修改的是最新一次 comment 的内容，则不需要该参数，就可以修改 comment。 ","permalink":"https://luciuschen.github.io/posts/main/20220503160055-git-skills/","summary":"删除以往的提交记录 git checkout --orphan latest_branch git add -A git commit -am \u0026#34;commit message\u0026#34; git branch -D main git branch -m main git push -f origin main 发现上次提交的内容有误，需要再次修改，但不想重复提交，而是合并到上一次提","title":"Git Skills"},{"content":"The Happens-before relation An event is something happening at one node (sending or receiving a message, or a local execution step).\nevent a happens before event b, written a → b.\n那么在分布式，有三种情况，满足其中一条，则 a 是发生在 b 之前：\na 和 b 发生在相同节点，并且按照本地节点的执行顺序，a 发生在 b 之前。\n事件 a 是发送消息 m，事件 b 是接收相同的消息 m（假定发送的消息都是唯一的）。\n有这么一个时间 c 满足，a → c 且 c → b。\nhappens-before relation 是局部的顺序：有可能存在既不满足 a → b 也不满足 b → a，这样 a 和 b 就是并行的，写作 a || b。\nHappen-before relation example Figure 1: happens-before-example\na → b, c → d, and e → f due to process order b → c and d → f due to messages m1 and m2 a → c, a → d, a → f, b → d, b → f, and c → f due to transitivity a || e, b || e, c || e, and d || e Causality Happens-before relation 和 Causality 在分布式系统中联系非常紧密\n当 a → b, 那么 a 可能是 b 的因。 当 a || b, a 和 b 之间不存在因果关系。 Figure 2: causality\nLet ≺ be a strict total order on events.\n如果 (a → b) ⇒ (a ≺ b) 符号 ≺ 就是所谓的因果顺序。\n因果关系的概念是从物理学中借鉴的，信息的传播速度不可能超过光速。因此如果事件 A 和事件 B 在空间上相距很远，但是在时间上相距很近，那么从事件 A 发出的信号不可能在事件 B 之前到达 B 的位置，反之亦然。因此 A 和 B 是肯定没有因果关系的。\n一个在空间上离 A 很近，时间上距离 A 很远的事件 C，将在 A 的光锥内，也就是说 A 的信号有可能到达 C，因此 A 可能影响 C。在分布式系统中，网络上的消息虽然不同于光束，但原理非常相似。\n","permalink":"https://luciuschen.github.io/posts/main/20220602202832-causality_and_happen_before_relation/","summary":"The Happens-before relation An event is something happening at one node (sending or receiving a message, or a local execution step). event a happens before event b, written a → b. 那么在分布式，有三种情况，满足其中一条，则 a 是发生在 b 之前： a 和 b 发生在相同节","title":"Causality and Happen-before relation"},{"content":"Remote Procedure Call 是一种=软件通信协议=，程序可以在不了解网络细节的前提下，向位于网络上的另外一台计算机中的本地程序请求服务。PRC 被用来像本地系统一样调用远程系统上的其他进程。\nRPC 是通过 Interface Definition Language (IDL) 来描述接口，使得在不同的平台上运行的不同程序编写的程序可以相互通信。(IDL 是不以任何一种特定编程语言的方式指定类型签名或者函数调用的语言。)\n基本上，你可以用 IDL 定义客户端和服务端之间的接口，这样 RPC 机制就可以创建跨网络调用功能所需要的代码存根（Code Stub）。\n+----------------+ | Client | | +----------+ | +---------------+ | | main | | | Server | | |----------| | | +----------+ | | | stub_cli |----(comms)---\u0026gt;| stub_svr | | | +----------+ | | |----------| | +----------------+ | | function | | | +----------+ | +---------------+ 在这个例子中，~main~ 没有在同一个程序中调用函数，而是调用了一个客户端存根函数（与函数的原型相同），该函数负责将信息打包，并通过通讯通道将其传送给另一个进程。\n这里可以是同一台机器或者不同机器，RPC 的优势之一就是能够随意移动服务器。\n在服务器中，有个「监听者」进程，它将接收这些信息并将其传递给服务器。服务器的存根接收信息，解包并将其传递给真正执行的函数。\n真正的函数运行后返回结果给到服务器存根，服务器存根可以将返回的信息打包，并将其传回给客户端存根。客户端存根再将其解包并传回给 ~main~。\n实际上的 IDL 大概像下面这样：\n[ uuid(f9f6be21-fd32-5577-8f2d-0800132bd567), version(0), endpoint(\u0026#34;ncadg_ip_udp:[1234]\u0026#34;, \u0026#34;dds:[19]\u0026#34;) ] interface function_iface { [idempotent] void function( [in] int handle, [out] int *status ); } 头部是一些用于链接客户端和服务端的网络信息，RPC 发生在「会话层」中。接口部分才是 IDL 编译器建立客户端和服务器端存根的地方，以便客户端和服务端能够进行通讯，使得 RPC 正常工作。\n","permalink":"https://luciuschen.github.io/posts/main/20220603220847-remote_procedure_call_rpc/","summary":"Remote Procedure Call 是一种=软件通信协议=，程序可以在不了解网络细节的前提下，向位于网络上的另外一台计算机中的本地程序请求服务。PRC 被用来像本地系统一样","title":"Remote Procedure Call (RPC)"},{"content":" 在开发过程中，stub 很多时候就是针对不可控制的部分进行模拟，例如 Mock。 在分布式中，stub 就是用于转换远程过程调用（RPC）期间客户端和服务端之间传递参数的一段代码。 ","permalink":"https://luciuschen.github.io/posts/main/20220604180341-stub/","summary":"在开发过程中，stub 很多时候就是针对不可控制的部分进行模拟，例如 Mock。 在分布式中，stub 就是用于转换远程过程调用（RPC）期间客户端","title":"Stub"},{"content":"拜占庭将军问题（Byzantine Generals Problem），是由莱斯利·兰波特在其同名论文中提出的分布式对等网络通信容错问题。\n在分布式计算中，不同的计算机通过通讯交换信息达成共识而按照同一套协作策略行动。但有时候，系统中的成员计算机可能出错而发送错误的信息，用于传递信息的通讯网络也可能导致信息损坏，使得网络中不同的成员关于全体协作的策略得出不同结论，从而破坏系统一致性。拜占庭将军问题被认为是容错性问题中最难的问题类型之一。\n容错率：Theorem: need 3ƒ+1 generals in total to tolerate ƒ malicious generals.\n","permalink":"https://luciuschen.github.io/posts/main/20220602202317-the_byzantine_generals_problem/","summary":"拜占庭将军问题（Byzantine Generals Problem），是由莱斯利·兰波特在其同名论文中提出的分布式对等网络通信容错问题。 在分布式计算中，不同","title":"The Byzantine generals problem"},{"content":"两军问题（英语：Two Generals\u0026rsquo; Problem）是计算机领域中的一个思想实验。两军问题显示，通过不可靠的通信通道交换信息并达成共识是难以实现的。在该问题中，两支军队的将军只能通过派遣信使穿越敌方领土来互相通信，以此约定在同一时间点共同进攻。该问题希望求解如何在两位将军派出的任何信使都可能被俘虏的情况下，就发动攻击的时间点达成一致。\n两军问题是拜占庭将军问题的一个特例，常被编入与计算机网络相关的入门课程中。在传输控制协议（TCP）相关的课程中，该问题可用作解释 TCP 协议无法保证通信双方之间的状态一致性的原因。该问题也适用于其他存在信息丢失的双方通信的情况。作为认识逻辑的一个重要概念，该问题突出了共识（英语：Common_knowledge_(logic)）的重要性。一些学者也将此问题称作两军悖论（英语：Two Generals Paradox）或协同进攻问题（英语：Coordinated Attack Problem）。两军问题是第一个被证明无解的计算机通信问题。该证明的重要意义在于，其显示了对于存在通信错误的更广泛的问题（如拜占庭将军问题），同样是无解的。这也为所有分布式一致性协议的实现提供了一个符合现实的预期。\n","permalink":"https://luciuschen.github.io/posts/main/20220602202247-the_two_generals_problem/","summary":"两军问题（英语：Two Generals\u0026rsquo; Problem）是计算机领域中的一个思想实验。两军问题显示，通过不可靠的通信通道交换信息并达成共识是难以实现的。在该","title":"The two generals problem"},{"content":"Plugin Scale Scale any frame, it’s contents, and all effects to any defined width or height. Sankey Connect Sankey Diagram Connect. ","permalink":"https://luciuschen.github.io/posts/main/20220503154744-figma/","summary":"Plugin Scale Scale any frame, it’s contents, and all effects to any defined width or height. Sankey Connect Sankey Diagram Connect. ","title":"Figma"},{"content":"Sankey diagram 使用软件：Figma Plugin: Sankey Connect 展现数据流动的利器 案例：工作流描述 初始的思路是按照流程图来画，用 Excalidraw 插件画起来很快，但不够明晰。工作流也是处理数据流动的过程，适合用 Sankey diagram 来展示。\n对比\nFigure 1: take-notes-draft\nFigure 2: take-notes-draft_1\nFigure 3: take-notes-sankey\n技巧\nConnect 的渐变色是将颜色从 Solid 改为 Linear，然后把两端的色块拖动到 Node 处并改为对应 Node 的颜色。 Connect 要尽量弧度舒缓，有美感；留白要均匀。 Heat Map 使用软件：Figma\n展现过程中频次高低\n案例：描述 GTD 和 Note-Taking 过程中思考频次高低。\nFigure 4: gtd_note_taking_dark\nFigure 5: gtd_note_taking_light\n","permalink":"https://luciuschen.github.io/posts/main/20220503145636-build_diagram/","summary":"Sankey diagram 使用软件：Figma Plugin: Sankey Connect 展现数据流动的利器 案例：工作流描述 初始的思路是按照流程图来画，用 Excalidraw 插件画起来很快，但不够明晰。工作流也是处理数","title":"Build Diagram"},{"content":"Introduction 最先接触到 Zettlekasten (German: \u0026ldquo;slip box\u0026rdquo;, plural zettlekästen) 是从 @Tisoga 的推文中得知，如获至宝。在这之前用过 MWeb（内测用户）、iA Writer、Bear、Notion、Obsidian（当时还不知道 Backlinks），都觉得不太合适，尤其是第一步文件夹的分类就让我头疼，很多内容是互相交叉的，并不是简单的可以归在一个分类下面，若是细分的分类过多，又会过于混乱，最后的结果就是“垃圾场”。\n根据 Zettlekasten 衍生出来的各种 APP 中的 Backlinks 将笔记串联起来，作为一个草稿箱，定期去整理回顾形成自己的知识。 另外一个极为吸引我的就是 Daily Notes 或者 Journals，非常适合我当前的工作场景。「生产问题」或者「零碎的需求」会不断从打断我的工作，有时候会非常紧急需要优先处理「需求」或者「生产问题」，解决后会有两种情况。\n问题或需求解决后，要花一些时间梳理之前在做的事情才能够重新接续之前的思路继续工作。\n问题解决后几个月遇到相同或类似的问题，虽然记得解决过，但是当时解决的思路以及细节需要注意的地方就模糊不清了。通常为了万无一失需要重复上次的工作，仔细查看过代码结合业务后，才能作出正确的判断，确保干净利落地解决问题。\n上面两种情况完全可以用 Journals 记录解决问题前的工作思路，记录解决问题后的思路，来避免上述两种情况发生。\nFigure 1: take-notes-sankey\n信息大爆炸的副作用就是信噪比降低，通过分阶段的信息处理，不断地归纳、处理形成自己的想法，并将其固化下来，作为知识库。\n流程设计 图中的流程其实就是多层的过滤器。\n从最初的信息源处到 Logseq 的过程，只需要考虑这个信息源是否值得读，是否值得扩展，答案确定则大胆地记入 Logseq。其中零散的思绪及文章阅读记录在 Journals 中，书籍这类大部头则在 page 中记录，前者因为零散在 Journals 中，需要加 page 的双链或 Tag。\nLogseq 中 Journals 中的事件重要的会被我移到 Org-roam 中的 Journals.org 文件中，这个文件类似于日记的作用，并不是每天都会记录，记录多了之后按照年份进行分割。\n从 Logseq 到 Org-roam 则是知识固化的过程，需要考虑该知识是否以后会被自己再次用到，是否值得扩展，答案确定则精炼后记入，并标明灵感来源，引用材料。因此，Logseq 中记录的都只能算是草稿，需要再次的整合，提高信噪比。\n对信息源处理时，可以用 Excalidraw 进行流程图、思维图等图的草稿绘制。后续有时间的时候再用 Figma 重新绘制，视觉和逻辑上的重新设计，使得阐述的内容更加直观。\n对于产品来说，通过设计降低理解门槛和使用门槛，是一件挺重要的事情。输出文章同样如此。\nOrg-roam 中也有收集想法的地方，Inbox.org，定期会进行清理。 notes 中 outline 结构是由 * 实现的，导出时是标题格式，为了随时可以导出发布，要注意 outline 结构。输出是通过 Org-export-dispatch 来转为 .md 或 .html 文件，为了更符合使用的格式，在 Org-roam 中做了一些设置。\nOrg-roam-ui 非常优秀，不管是 UI 还是操作性，可以明晰的查看笔记之间的关联，知识是否形成闭环，哪些知识还需要进行拓展阅读。\n准则 卡片应该具有原子性。这点和编程的原则很像，一个方法只做一件事，在这里也就是只记录一个主题的内容。\n卡片内容应该具有独立性。这点和上面并不冲突，设想一下，为了保持每个卡片的纯净，X 和 Y 之间的关系，你可能会用 Z 去链接他们。但回顾的时候，没有 Z，单纯回顾 X 或 Y 无法得知两者之间的关联。所以这里不管在 X 或者 Y 中去描述与对方的关系都是可以的，一点点内容的冗余可以使得内容更加独立。\n遵守奥卡姆剃刀原则。对新工具充分调研，是否满足自己的需求后再考虑替换或增加到现有工作流当中。\nLiterature Notes 需要及时回顾，在一两天内转化为 Permanent Notes 或者直接删掉。\n误区 All-In-One 的思想。Markdown 的扩展语法实现并不统一，扩展语法的内容导出时经常要手动兼容，或不可再用。云端服务的不可持续性，互联网这么多年已经太多的云端服务用着用着就停掉了。\nPermanent Notes 并不是不需要回顾和修改了。\n记太多的内容。从资料中复制大量的原文。笔记应该是对所读内容的提炼：用自己的话改写观点和概念有助于加强理解。\n太复杂的笔记流程。复杂的工作流通常需要自动化，但自动化不利于笔记的整理，形成最重笔记时应该慎重考虑哪些是需要保留的，否则知识库就会变成垃圾场。\n","permalink":"https://luciuschen.github.io/posts/article/20220505162419-how_i_take_notes/","summary":"Introduction 最先接触到 Zettlekasten (German: \u0026ldquo;slip box\u0026rdquo;, plural zettlekästen) 是从 @Tisoga 的推文中得知，如获至宝。在这之前用过 MWeb（内测用户）、iA Writer、Bear、","title":"How I Take Notes"},{"content":"Introduction 2013年时，第一次接触到 GTD 是因为 Omnifocus 的美观，为此我还花了 $9.99 买了 iOS 的客户端。但从那个时候起，我一直没有用好 GTD 这套理论和各种工具，例如 Omnifocus、Things 等等。\n一直不明白问题出在哪里，一天下来不管是 Today 还是 Inbox 当中的 To-Do 不仅没有变少，甚至更多了。自我怀疑、自我谴责让自己觉得是拖延症、懒造成了 To-Do 积压。\n回顾过去几年中，除了 Things 以外，我还使用了 Due 和 Fantastical 这两款软件。前者是吃药的时候，循环提醒该吃药了；后者是今天或者未来某天必须要做的事情，为了不让我忘记这个事情，哪怕我不确定这个事情在当天的哪个时间段做，都会给它加一个提醒，这样即便是过了时间，只要没有 checked 就会一直在锁屏或者下拉通知内，这样我就可以*不断地被提醒，找到合适的时间段去完成这件事情*​。\n至于 Things 时常被我厌恶，因为我有太多的 To-Do 积压在里面。每次打开它都有种翻开垃圾桶的感觉，没错，它就是垃圾桶。我再次捡起 Things 用的时候，基本都是我把“过期了的”、“没有意义的” To-Do 清空了才可以。这是一个循环往复的过程，过程中不断地伤害着我自己的自信心，并让我感到焦虑，永远做不完的事情，越积越多。\n在这样的情况下我了解到了 Implementation Intention。\nImplementation Intention 执行意图由心理学家 Peter M.Gollitzer 提出，是个体为实现某一目标制定的一种计划，表现为“如果－那么”形式，例如“如果我遇到突发情况，那么我将保持冷静”。\n普通人思考目标的时候，使用的是目标意图，即：我要做什么、我要成为什么。目标意图有个最大的缺点：建立目标容易，执行目标很难。而执行意图更多思考的是要怎么做的问 题。\n执行意图明确了个体在何时何地，以什么方式来实现目标，从而让个体更加容易地提取具体情景线索的心理表征，并通过这些线索建立起与目标所指行为的联系。在建立起线索和目标行为的联系之后，个体在随后遇到线索所指向的情景时（如考场），便可以用一种自动化的方式执行事先形成的计划，达成预设的目标。重要的是，执行意图的这种过程是自动化进行的，并不需要个体有意识地进行控制。\n再结合成功实行 GTD 的案例「Deep Habits: The Importance of Planning Every Minute of Your Work Day」和「Be a Schedule Builder, Not a To-Do List Maker」，发现他们都会去在前一天花费一些时间去细化第二天的任务列表，甚至精确到分钟，这其实就是上面提到的 Implementation Intention 的实际操作，When Where and How。\n案例1当中是通过日历来安排一天的工作，细致到分钟。若发生变故需要变更，则在右侧重新记录变更后的安排。\nFigure 1: gtd_dark\n案例2中则从容很多，不仅仅是安排了工作的内容，休闲娱乐的内容也会排在日历当中。(下图来自于案例2)\nFigure 2: gtd_schedule_builder\n其实回顾到上面我提到使用 Due 和 Fantastical 的经历，当中已经包含了执行意图的概念，任务都非常明晰，是今天必须要做的，是今天有非常合适的情景去做的，只不过是我没有意识到。\n「执行意图」会让人主动思考，避免囤积过多的任务。 举个例子，按照执行意图的方法。如果我买了一本书，那么我就要在最近的闲暇时间都去读它，并在读完后写读后感总结一下。那么当我买书或者安排任务的时候就会想到买书不仅仅是一个完结，后续意味着我要去读它，并写读后感等一大堆的操作，这样就不会去在自己当前书还没有读完的情况下，就去安排下一本书。\n例子中的场景和平时从 Inbox 中安排任务很类似，造成任务完不成，积压，是因为没有安排好任务的情景关系，何时、何地、如何去做这件事情，仅仅就是目标意图，我要做这些事情。\n没有对每个任务细致的思考前，无法把握任务的工作量，适合完成的场景，也就无法把控今天安排的任务是否都能完成。但刚刚开始接触这套方法的人，难免会因为对工作细节不熟悉导致工作量评估不准确的情况。\n「执行意图」消除了在何时何地做某事的模糊性。 例如，询问选民如何前往投票站等简单的问题，已经被证明可以提高当天的投票率。\n在这个例子当中，被问的选民其实受到了引导，增加去投票这件事情的确定性。我们也可以利用同样的方法，明确任务，顺着 if...then... 的顺序去完成任务。\n回顾 @mikhails5v 在 tweet thread 中提到了他在使用 Things 的 1.5 年中，对于没有完成的任务，在每晚回顾时，手动的去把今天的任务清空，已完成的任务会让他很有成就感；未完成的任务则在思考后移到后面适合的时候，或者重新放回 Inbox，甚至删掉它们。确保了每日的任务都是清空的状态，没有负罪感。即便是没有完成的任务，在每晚也会重新回顾，思考后续是否有合适的情景去完成它，或者干脆觉得没有执行的必要删除掉。\n阶段性思考 note-taking and knowledge creation will always require large amounts of brain work. On the other hand, GTD makes task management a simple, effortless process.\n对比我在 How I Take Notes 中写的笔记的工作流，To-Do 和 Note-Taking 确实存在区别。\nGTD 中 Capture 是最不需要思考的，有什么东西直接记录到 Inbox 当中，清空当前的灵感，专注眼前的事情。例如，Things 中快速呼出 Inbox 的输入框；Org-roam 中写在 .org 文件中的 To-Do 都会集中在 Agenda 中；Logseq 中写在 Journals 中的 To-Do 也可以在 Pages 中按照自己的需求定制查询（复杂的查询有些门槛）。后续处理，按照执行意图的方法去评估 To-Do 适合的情景；较大的任务需要进行拆分成若干小任务，甚至形成一个专门的项目分为不同阶段去完成。\nNote-Taking 相反，从阅读就开始思考，随后各种灵感迸发，记录下来进行整理，去芜存菁后继续扩展，定期回顾后形成自己的知识并输出，这个时候的写作反而是最不需要动脑的部分了。以下的 Heat Map 表示不同阶段思考的程度。\nFigure 3: gtd_note_taking_dark\nTo-Do 是否需要独立管理 至于 To-Do 和 Note-Taking 是否分开，我的看法是逻辑上分开，物理上并不一定分开。\n一天 24 小时是由不同阶段组成的，工作、生活、娱乐等等，都会产生 To-Do。那么管理 To-Do 也可以分为不同的场景。\n工作 工作上做好日志记录，是个好习惯，可以方便查阅当时的想法，解决问题的思路，以及相关人员是谁，就跟航海日志一样。这个时候产生的 To-Do 就是与日志息息相关的，上下文联系紧密。加上 Capture 的原则是尽快记录，并且不打断现有的思路，最好的方法就是记录在笔记当中（比如Logseq 的 Journals）。\n汇总的话就更加简单了，Logseq 通过 Clojure 的查询语句就可以完成汇总，不会这门语言也没有关系，Discord 中有专门的 Channel 可以提问或讨论。每天上班的第一件事情就是回顾汇总，结合工作进度安排今天的工作。\n生活 生活中琐事居多，场景也非常繁杂，这个时候完全可以用单独的 App 来进行管理。Things 来收集拆分任务，Fantastical 来进行一天时间的分配以及未来几天需要提醒的任务，Due 来提醒重复任务。\nConclusion 警惕 All-In-One 的想法，并不是所有场景都有统一的解决方案。工作和生活分开管理 To-Do 还有个好处，休假的时候你完全可以屏蔽掉工作的内容。\n另外不管工作和生活中，长期计划用甘特图来管理还是非常不错的，确立里程碑，控制进度，把握长期计划的走向。\n","permalink":"https://luciuschen.github.io/posts/article/20220503143427-gtd/","summary":"Introduction 2013年时，第一次接触到 GTD 是因为 Omnifocus 的美观，为此我还花了 $9.99 买了 iOS 的客户端。但从那个时候起，我一直没有用好 GTD 这套理论和各种工具，例如 Omni","title":"Implementation Intention GTD"}]