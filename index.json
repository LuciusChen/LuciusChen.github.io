[{"content":" 在开发过程中，stub 很多时候就是针对不可控制的部分进行模拟，例如 Mock。 在分布式中，stub 就是用于转换远程过程调用（RPC）期间客户端和服务端之间传递参数的一段代码。 ","permalink":"https://luciuschen.github.io/posts/main/20220604180341-stub/","summary":"在开发过程中，stub 很多时候就是针对不可控制的部分进行模拟，例如 Mock。 在分布式中，stub 就是用于转换远程过程调用（RPC）期间客户端","title":"Stub"},{"content":"拜占庭将军问题（Byzantine Generals Problem），是由莱斯利·兰波特在其同名论文中提出的分布式对等网络通信容错问题。\n在分布式计算中，不同的计算机通过通讯交换信息达成共识而按照同一套协作策略行动。但有时候，系统中的成员计算机可能出错而发送错误的信息，用于传递信息的通讯网络也可能导致信息损坏，使得网络中不同的成员关于全体协作的策略得出不同结论，从而破坏系统一致性。拜占庭将军问题被认为是容错性问题中最难的问题类型之一。\n容错率：Theorem: need 3ƒ+1 generals in total to tolerate ƒ malicious generals.\n","permalink":"https://luciuschen.github.io/posts/main/20220602202317-the_byzantine_generals_problem/","summary":"拜占庭将军问题（Byzantine Generals Problem），是由莱斯利·兰波特在其同名论文中提出的分布式对等网络通信容错问题。 在分布式计算中，不同","title":"The Byzantine generals problem"},{"content":"两军问题（英语：Two Generals\u0026rsquo; Problem）是计算机领域中的一个思想实验。两军问题显示，通过不可靠的通信通道交换信息并达成共识是难以实现的。在该问题中，两支军队的将军只能通过派遣信使穿越敌方领土来互相通信，以此约定在同一时间点共同进攻。该问题希望求解如何在两位将军派出的任何信使都可能被俘虏的情况下，就发动攻击的时间点达成一致。\n两军问题是拜占庭将军问题的一个特例，常被编入与计算机网络相关的入门课程中。在传输控制协议（TCP）相关的课程中，该问题可用作解释 TCP 协议无法保证通信双方之间的状态一致性的原因。该问题也适用于其他存在信息丢失的双方通信的情况。作为认识逻辑的一个重要概念，该问题突出了共识（英语：Common_knowledge_(logic)）的重要性。一些学者也将此问题称作两军悖论（英语：Two Generals Paradox）或协同进攻问题（英语：Coordinated Attack Problem）。两军问题是第一个被证明无解的计算机通信问题。该证明的重要意义在于，其显示了对于存在通信错误的更广泛的问题（如拜占庭将军问题），同样是无解的。这也为所有分布式一致性协议的实现提供了一个符合现实的预期。\n","permalink":"https://luciuschen.github.io/posts/main/20220602202247-the_two_generals_problem/","summary":"两军问题（英语：Two Generals\u0026rsquo; Problem）是计算机领域中的一个思想实验。两军问题显示，通过不可靠的通信通道交换信息并达成共识是难以实现的。在该","title":"The two generals problem"},{"content":"Remote Procedure Call 是一种=软件通信协议=，程序可以在不了解网络细节的前提下，向位于网络上的另外一台计算机中的本地程序请求服务。PRC 被用来像本地系统一样调用远程系统上的其他进程。\nRPC 是通过 Interface Definition Language (IDL) 来描述接口，使得在不同的平台上运行的不同程序编写的程序可以相互通信。(IDL 是不以任何一种特定编程语言的方式指定类型签名或者函数调用的语言。)\n基本上，你可以用 IDL 定义客户端和服务端之间的接口，这样 RPC 机制就可以创建跨网络调用功能所需要的代码存根（Code Stub）。\n+----------------+ | Client | | +----------+ | +---------------+ | | main | | | Server | | |----------| | | +----------+ | | | stub_cli |----(comms)---\u0026gt;| stub_svr | | | +----------+ | | |----------| | +----------------+ | | function | | | +----------+ | +---------------+ 在这个例子中，~main~ 没有在同一个程序中调用函数，而是调用了一个客户端存根函数（与函数的原型相同），该函数负责将信息打包，并通过通讯通道将其传送给另一个进程。\n这里可以是同一台机器或者不同机器，RPC 的优势之一就是能够随意移动服务器。\n在服务器中，有个「监听者」进程，它将接收这些信息并将其传递给服务器。服务器的存根接收信息，解包并将其传递给真正执行的函数。\n真正的函数运行后返回结果给到服务器存根，服务器存根可以将返回的信息打包，并将其传回给客户端存根。客户端存根再将其解包并传回给 ~main~。\n实际上的 IDL 大概像下面这样：\n[ uuid(f9f6be21-fd32-5577-8f2d-0800132bd567), version(0), endpoint(\u0026#34;ncadg_ip_udp:[1234]\u0026#34;, \u0026#34;dds:[19]\u0026#34;) ] interface function_iface { [idempotent] void function( [in] int handle, [out] int *status ); } 头部是一些用于链接客户端和服务端的网络信息，RPC 发生在「会话层」中。接口部分才是 IDL 编译器建立客户端和服务器端存根的地方，以便客户端和服务端能够进行通讯，使得 RPC 正常工作。\n","permalink":"https://luciuschen.github.io/posts/main/20220603220847-remote_procedure_call_rpc/","summary":"Remote Procedure Call 是一种=软件通信协议=，程序可以在不了解网络细节的前提下，向位于网络上的另外一台计算机中的本地程序请求服务。PRC 被用来像本地系统一样","title":"Remote Procedure Call (RPC)"},{"content":"Remote Procedure Call Remote Procedure Call (RPC) 使得调用远程函数就像调用本地函数一样，这样就不需要关心资源的具体问题，实际上 RPC 是将方法调用转换成了网络通信。但是遇到通信失败怎么办？\n如果在函数调用过程中，服务挂了？ 如果消息丢失了？ 如果消息延迟了？ 如果出了问题，回复消息是否安全？ 要解决这些问题，就需要将网络以及节点之间的情况抽象出来，以及时序的问题。在设计分布式算法时，我们需要更加抽象一点，以便我们更好的推理整个过程。\n网络行为 The two generals problem 描述了网络通信丢失的场景。\n我们假设两个节点之是间双向的点对点的通信。\nReliable links 一条消息只会在被一个节点发送的时候才会收到，并且消息是可以重新排序的。\n中间没有伪造消息等行为，发送了就一定会被收到。\nFair-loss links 消息可能会丢失、重复或重新排序，如果你一直重新发送，消息终将会传递过去。\n每次发送消息成功的概率都是非零，这个时候只要一直重试，我们就假设消息一定会传递到另外一个节点。\nFair-losl links 其实可以通过不断的重试以及并且对重复收到的消息去重，就可以达到 Reliable links 的效果。\nArbitrary links 可能传递过程中会有恶意的第三方对消息进行干预。\n比如公共场合的公共 WiFi 就会出现这种情况。\nArbitrary links 通过 TLS 的加持，就可以达到 Fair-loss links 的效果。\n节点行为 The Byzantine generals problem 描述了节点出错，导致全体协作策略失败以及容错率的问题。\n我们假设每个节点都执行指定的算法，假设有以下情况。\nCrash-stop (fail-stop) 如果一个节点出现问题挂了，并且在这之后永远停机。\nCrash-recovery (fail-recovery) 一个节点挂了，并丢失了内存状态，但会在过段时间后恢复。\nByzantine （fail-arbitrary) 节点偏离了原本的算法，可能会发生任何事情，包括崩溃或者恶意的行为。\n同步（时序）假定 Synchronous 消息延迟不超过已知的上限。到达这个上限后，消息要么被传递，要么丢失。节点以已知的速度执行算法。每一步代码的执行都有执行时间的上限。\nPartically synchronous 系统中一部分时间内是异步的，另一部分是同步的。\nAsynchronous 消息可以任意地被延迟，节点可以任意地暂停，并没有时序上的保证。\n","permalink":"https://luciuschen.github.io/posts/main/20220602202933-distribution_system/","summary":"Remote Procedure Call Remote Procedure Call (RPC) 使得调用远程函数就像调用本地函数一样，这样就不需要关心资源的具体问题，实际上 RPC 是将方法调用转换成了网络通信。但是遇到通信失败怎","title":"Distribution System"},{"content":"Plugin Scale Scale any frame, it’s contents, and all effects to any defined width or height. Sankey Connect Sankey Diagram Connect. ","permalink":"https://luciuschen.github.io/posts/main/20220503154744-figma/","summary":"Plugin Scale Scale any frame, it’s contents, and all effects to any defined width or height. Sankey Connect Sankey Diagram Connect. ","title":"Figma"},{"content":"Introduction 说起来好笑，我选择 Org-roam 作为自己 PKM 流程最终知识固化的地方，还是因为与之配合的 Org-roam-ui 的美观，随后发现易用性上也很不错。2013年时，第一次接触到 GTD 也是因为 Omnifocus 的美观，为此我还花了 $9.99 买了 iOS 的客户端。\nOrg-roam 是基于 Emacs 平台，对于直接触过 Vim 的我来讲，是个全新的东西，官方是这么形容它的。\nEmacs outshines all other editing software in approximately the same way that the noonday sun does the stars. It is not just bigger and brighter; it simply makes everything else vanish.\n– Neal Stephenson, In the Beginning was the Command Line (1998)\nInstall Emacs With Homebrew First, Doom’s dependencies:\nbrew install git ripgrep brew install coreutils fd xcode-selected --install emacs-mac. It offers good integration with macOS, native emojis and better childframe support.\nbrew tap railwaycat/emacsmacport brew install emacs-mac --with-modules ln -s /usr/local/opt/emacs-mac/Emacs.app /Applications/Emacs.app Doom Doctor 问题 Warning: unable to detect fonts because fontconfig isn\u0026rsquo;t installed\nbrew install fontconfig ! Couldn\u0026rsquo;t find shellcheck. Shell script linting will not work\nbrew install shellcheck Doom Emacs With Emacs and Doom\u0026rsquo;s dependencies installed, next is to install Doom Emacs itself:\ngit clone https://github.com/hlissner/doom-emacs ~/.emacs.d ~/.emacs.d/bin/doom install 如果提示 .emacs.d 已存在，删除重新执行上述命令即可。\n.zshrc 中需要添加 export PATH=\u0026quot;$HOME/.emacs.d/bin:$PATH ，这样就可以直接使用 doom 命令了。\nOrg-roam 具体的配置文件在 .doom.d/ 下，参见 .doom.d。\nShortcuts Shortcuts 功能 备注 C-RET 在当前 headline 所属的内容后建立一个同级 headline 无 headline 时创建一个一级 headline M-RET 在当前 headline 后建立一个同级 headline 同上 M-right 降低当前 headline 的层级 M-left 提高当前 headline 的层级 M-up 将当前 headline 及其内容作为整体向上移动 M-down 将当前 headline 及其内容作为整体向下移动 C-return 在当前列表项的内容后建立一个同级列表项 光标在列表项同一行时有效 M-RET 在当前列表项后建立一个同级列表项 同上 M-right 降低当前列表项的层级 同上 M-left 提高当前列表项的层级 同上 M-up 将当前列表项及其内容作为整体向上移动 同上 M-down 将当前列表项及其内容作为整体向下移动 同上 C-x-o 切换窗口 C-x 中有很多操作，可以看提示。 C-c C-c 在创建 node 编写完毕后快速保存 C-g 取消操作 C-x-d 进入 dired 模式 SPC f r 查找最近文件 C-c C-x C-v 显示图片 Shortcuts 功能 备注 C-c C-s 设置任务开始时间 C-c C-d 设置任务截止时间 C-c C-t 改变任务状态 S-Up/Down 设置任务优先级 [#A], [#B], [#C] C-c C-x C-i 开始任务计时 C-c C-x C-o 终止任务计时 C-c [ 将当前文件加入 Org-Agenda C-c ] 将当前文件从 Org-Agenda 移除 Shortcuts 功能 备注 t 在 Org-Agenda 的任务条目上， 修改任务状态。 C-c C-x C-a 归档 C-c C-w activate refile I 在 Org-Agenda 的任务条目上， 开始计时。 O 在 Org-Agenda 的任务条目上， 终止计时。 z 在任务上添加 note R clock mode, 显示耗时。 Org grammar This is almost anything you need to know about Org mode syntax:\n* This Is A Heading ** This Is A Sub-Heading *** And A Sub-Sub-Heading Paragraphs are separated by at least one empty line. *bold* /italic/ _underlined_ +strikethrough+ =monospaced= [[http://Karl-Voit.at][Link description]] http://Karl-Voit.at → link without description - list item - another item - sub-item 1. also enumerated 2. if you like - [ ] yet to be done - [X] item which is done : Simple pre-formatted text such as for source code. : This also respects the line breaks. *bold* is not bold here. code block\nmyresult = 42 * 23 print(\u0026#39;Hello Europe! \u0026#39; + str(myresult)) table\n| My Column 1 | My Column 2 | Last Column | |-------------+-------------+-------------| | 42 | foo | bar | | 23 | baz | abcdefg | |-------------+-------------+-------------| | 65 | | | Export to Markdown 这里用的是 ox-pandoc， ~M-x org-pandoc-export-as-gfm~算是我找到最符合 MarkDown 语法的转换了，Emacs 自己的转换会将 Table 转换成 HTML 标签的格式。\n","permalink":"https://luciuschen.github.io/posts/main/20220505220832-org_roam/","summary":"Introduction 说起来好笑，我选择 Org-roam 作为自己 PKM 流程最终知识固化的地方，还是因为与之配合的 Org-roam-ui 的美观，随后发现易用性上也很不错。2013年时，第一次接触到 GTD 也","title":"Org-roam"},{"content":"Sankey diagram 使用软件：Figma Plugin: Sankey Connect 展现数据流动的利器 案例：工作流描述 初始的思路是按照流程图来画，用 Excalidraw 插件画起来很快，但不够明晰。工作流也是处理数据流动的过程，适合用 Sankey diagram 来展示。\n对比\nFigure 1: take-notes-draft\nFigure 2: take-notes-draft_1\nFigure 3: take-notes-sankey\n技巧\nConnect 的渐变色是将颜色从 Solid 改为 Linear，然后把两端的色块拖动到 Node 处并改为对应 Node 的颜色。 Connect 要尽量弧度舒缓，有美感；留白要均匀。 Heat Map 使用软件：Figma\n展现过程中频次高低\n案例：描述 GTD 和 Note-Taking 过程中思考频次高低。\nFigure 4: gtd_note_taking_dark\nFigure 5: gtd_note_taking_light\n","permalink":"https://luciuschen.github.io/posts/main/20220503145636-build_diagram/","summary":"Sankey diagram 使用软件：Figma Plugin: Sankey Connect 展现数据流动的利器 案例：工作流描述 初始的思路是按照流程图来画，用 Excalidraw 插件画起来很快，但不够明晰。工作流也是处理数","title":"Build Diagram"},{"content":"Introduction 最先接触到 Zettlekasten (German: \u0026ldquo;slip box\u0026rdquo;, plural zettlekästen) 是从 @Tisoga 的推文中得知，如获至宝。在这之前用过 MWeb（内测用户）、iA Writer、Bear、Notion、Obsidian（当时还不知道 Backlinks），都觉得不太合适，尤其是第一步文件夹的分类就让我头疼，很多内容是互相交叉的，并不是简单的可以归在一个分类下面，若是细分的分类过多，又会过于混乱，最后的结果就是“垃圾场”。\n根据 Zettlekasten 衍生出来的各种 APP 中的 Backlinks 将笔记串联起来，作为一个草稿箱，定期去整理回顾形成自己的知识。 另外一个极为吸引我的就是 Daily Notes 或者 Journals，非常适合我当前的工作场景。「生产问题」或者「零碎的需求」会不断从打断我的工作，有时候会非常紧急需要优先处理「需求」或者「生产问题」，解决后会有两种情况。\n问题或需求解决后，要花一些时间梳理之前在做的事情才能够重新接续之前的思路继续工作。\n问题解决后几个月遇到相同或类似的问题，虽然记得解决过，但是当时解决的思路以及细节需要注意的地方就模糊不清了。通常为了万无一失需要重复上次的工作，仔细查看过代码结合业务后，才能作出正确的判断，确保干净利落地解决问题。\n上面两种情况完全可以用 Journals 记录解决问题前的工作思路，记录解决问题后的思路，来避免上述两种情况发生。\nFigure 1: take-notes-sankey\n信息大爆炸的副作用就是信噪比降低，通过分阶段的信息处理，不断地归纳、处理形成自己的想法，并将其固化下来，作为知识库。\n流程设计 图中的流程其实就是多层的过滤器。\n从最初的信息源处到 Logseq 的过程，只需要考虑这个信息源是否值得读，是否值得扩展，答案确定则大胆地记入 Logseq。其中零散的思绪及文章阅读记录在 Journals 中，书籍这类大部头则在 page 中记录，前者因为零散在 Journals 中，需要加 page 的双链或 Tag。\nLogseq 中 Journals 中的事件重要的会被我移到 Org-roam 中的 Journals.org 文件中，这个文件类似于日记的作用，并不是每天都会记录，记录多了之后按照年份进行分割。\n从 Logseq 到 Org-roam 则是知识固化的过程，需要考虑该知识是否以后会被自己再次用到，是否值得扩展，答案确定则精炼后记入，并标明灵感来源，引用材料。因此，Logseq 中记录的都只能算是草稿，需要再次的整合，提高信噪比。\n对信息源处理时，可以用 Excalidraw 进行流程图、思维图等图的草稿绘制。后续有时间的时候再用 Figma 重新绘制，视觉和逻辑上的重新设计，使得阐述的内容更加直观。\n对于产品来说，通过设计降低理解门槛和使用门槛，是一件挺重要的事情。输出文章同样如此。\nOrg-roam 中也有收集想法的地方，Inbox.org，定期会进行清理。 notes 中 outline 结构是由 * 实现的，导出时是标题格式，为了随时可以导出发布，要注意 outline 结构。输出是通过 Org-export-dispatch 来转为 .md 或 .html 文件，为了更符合使用的格式，在 Org-roam 中做了一些设置。\nOrg-roam-ui 非常优秀，不管是 UI 还是操作性，可以明晰的查看笔记之间的关联，知识是否形成闭环，哪些知识还需要进行拓展阅读。\n准则 卡片应该具有原子性。这点和编程的原则很像，一个方法只做一件事，在这里也就是只记录一个主题的内容。\n卡片内容应该具有独立性。这点和上面并不冲突，设想一下，为了保持每个卡片的纯净，X 和 Y 之间的关系，你可能会用 Z 去链接他们。但回顾的时候，没有 Z，单纯回顾 X 或 Y 无法得知两者之间的关联。所以这里不管在 X 或者 Y 中去描述与对方的关系都是可以的，一点点内容的冗余可以使得内容更加独立。\n遵守奥卡姆剃刀原则。对新工具充分调研，是否满足自己的需求后再考虑替换或增加到现有工作流当中。\nLiterature Notes 需要及时回顾，在一两天内转化为 Permanent Notes 或者直接删掉。\n误区 All-In-One 的思想。Markdown 的扩展语法实现并不统一，扩展语法的内容导出时经常要手动兼容，或不可再用。云端服务的不可持续性，互联网这么多年已经太多的云端服务用着用着就停掉了。\nPermanent Notes 并不是不需要回顾和修改了。\n记太多的内容。从资料中复制大量的原文。笔记应该是对所读内容的提炼：用自己的话改写观点和概念有助于加强理解。\n太复杂的笔记流程。复杂的工作流通常需要自动化，但自动化不利于笔记的整理，形成最重笔记时应该慎重考虑哪些是需要保留的，否则知识库就会变成垃圾场。\n","permalink":"https://luciuschen.github.io/posts/article/20220505162419-how_i_take_notes/","summary":"Introduction 最先接触到 Zettlekasten (German: \u0026ldquo;slip box\u0026rdquo;, plural zettlekästen) 是从 @Tisoga 的推文中得知，如获至宝。在这之前用过 MWeb（内测用户）、iA Writer、Bear、","title":"How I Take Notes"}]