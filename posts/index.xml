<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Posts on Lucius&#39;s PKM</title>
    <link>https://luciuschen.github.io/posts/</link>
    <description>Recent content in Posts on Lucius&#39;s PKM</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 04 Jun 2022 20:05:18 +0800</lastBuildDate><atom:link href="https://luciuschen.github.io/posts/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Org-roam</title>
      <link>https://luciuschen.github.io/posts/20220505220832-org_roam/</link>
      <pubDate>Sat, 04 Jun 2022 20:05:18 +0800</pubDate>
      
      <guid>https://luciuschen.github.io/posts/20220505220832-org_roam/</guid>
      <description>Introduction 说起来好笑，我选择 Org-roam 作为自己 PKM 流程最终知识固化的地方，还是因为与之配合的 Org-roam-ui 的美观，随后发现易用性上也很不错。2013年时，第一次接触到 GTD 也</description>
      <content:encoded><![CDATA[<h2 id="introduction">Introduction</h2>
<p>说起来好笑，我选择 Org-roam 作为自己 PKM 流程最终知识固化的地方，还是因为与之配合的 Org-roam-ui 的美观，随后发现易用性上也很不错。2013年时，第一次接触到 GTD 也是因为 Omnifocus 的美观，为此我还花了 $9.99 买了 iOS 的客户端。</p>
<p>Org-roam 是基于 Emacs 平台，对于直接触过 Vim 的我来讲，是个全新的东西，官方是这么形容它的。</p>
<blockquote>
<p>Emacs outshines all other editing software in approximately the same way that the noonday sun does the stars. It is not just bigger and brighter; it simply makes everything else vanish.</p>
<p>– Neal Stephenson, In the Beginning was the Command Line (1998)</p>
</blockquote>
<h2 id="install-emacs-with-homebrew">Install Emacs With Homebrew</h2>
<p>First, Doom’s dependencies:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>brew install git ripgrep
</span></span><span style="display:flex;"><span>brew install coreutils fd
</span></span><span style="display:flex;"><span>xcode-selected --install
</span></span></code></pre></div><p><a href="https://bitbucket.org/mituharu/emacs-mac/src">emacs-mac</a>. It offers good integration with macOS, native emojis and better childframe support.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>brew tap railwaycat/emacsmacport
</span></span><span style="display:flex;"><span>brew install emacs-mac --with-modules
</span></span><span style="display:flex;"><span>ln -s /usr/local/opt/emacs-mac/Emacs.app /Applications/Emacs.app
</span></span></code></pre></div><h3 id="doom-doctor-问题"><code>Doom Doctor</code> 问题</h3>
<ol>
<li>
<p>Warning: unable to detect fonts because fontconfig isn&rsquo;t installed</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>    brew install fontconfig
</span></span></code></pre></div></li>
<li>
<p>! Couldn&rsquo;t find shellcheck. Shell script linting will not work</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>    brew install shellcheck
</span></span></code></pre></div></li>
</ol>
<h2 id="doom-emacs">Doom Emacs</h2>
<p>With Emacs and Doom&rsquo;s dependencies installed, next is to install Doom Emacs itself:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-shell" data-lang="shell"><span style="display:flex;"><span>git clone https://github.com/hlissner/doom-emacs ~/.emacs.d
</span></span><span style="display:flex;"><span>~/.emacs.d/bin/doom install
</span></span></code></pre></div><p>如果提示 <code>.emacs.d</code> 已存在，删除重新执行上述命令即可。</p>
<p><code>.zshrc</code> 中需要添加 <code>export PATH=&quot;$HOME/.emacs.d/bin:$PATH</code> ，这样就可以直接使用 <code>doom</code> 命令了。</p>
<h2 id="org-roam">Org-roam</h2>
<p>具体的配置文件在 <code>.doom.d/</code> 下，参见 <a href="https://github.com/LuciusChen/dotfiles/tree/master/.doom.d">.doom.d</a>。</p>
<h2 id="shortcuts">Shortcuts</h2>
<table>
<thead>
<tr>
<th>Shortcuts</th>
<th>功能</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>C-RET</code></td>
<td>在当前 headline 所属的内容后建立一个同级 headline</td>
<td>无 headline 时创建一个一级 headline</td>
</tr>
<tr>
<td><code>M-RET</code></td>
<td>在当前 headline 后建立一个同级 headline</td>
<td>同上</td>
</tr>
<tr>
<td><code>M-right</code></td>
<td>降低当前 headline 的层级</td>
<td></td>
</tr>
<tr>
<td><code>M-left</code></td>
<td>提高当前 headline 的层级</td>
<td></td>
</tr>
<tr>
<td><code>M-up</code></td>
<td>将当前 headline 及其内容作为整体向上移动</td>
<td></td>
</tr>
<tr>
<td><code>M-down</code></td>
<td>将当前 headline 及其内容作为整体向下移动</td>
<td></td>
</tr>
<tr>
<td><code>C-return</code></td>
<td>在当前列表项的内容后建立一个同级列表项</td>
<td>光标在列表项同一行时有效</td>
</tr>
<tr>
<td><code>M-RET</code></td>
<td>在当前列表项后建立一个同级列表项</td>
<td>同上</td>
</tr>
<tr>
<td><code>M-right</code></td>
<td>降低当前列表项的层级</td>
<td>同上</td>
</tr>
<tr>
<td><code>M-left</code></td>
<td>提高当前列表项的层级</td>
<td>同上</td>
</tr>
<tr>
<td><code>M-up</code></td>
<td>将当前列表项及其内容作为整体向上移动</td>
<td>同上</td>
</tr>
<tr>
<td><code>M-down</code></td>
<td>将当前列表项及其内容作为整体向下移动</td>
<td>同上</td>
</tr>
<tr>
<td><code>C-x-o</code></td>
<td>切换窗口</td>
<td>C-x 中有很多操作，可以看提示。</td>
</tr>
<tr>
<td><code>C-c C-c</code></td>
<td>在创建 node 编写完毕后快速保存</td>
<td></td>
</tr>
<tr>
<td><code>C-g</code></td>
<td>取消操作</td>
<td></td>
</tr>
<tr>
<td><code>C-x-d</code></td>
<td>进入 dired 模式</td>
<td></td>
</tr>
<tr>
<td><code>SPC f r</code></td>
<td>查找最近文件</td>
<td></td>
</tr>
<tr>
<td><code>C-c C-x C-v</code></td>
<td>显示图片</td>
<td></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Shortcuts</th>
<th>功能</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>C-c C-s</code></td>
<td></td>
<td>设置任务开始时间</td>
</tr>
<tr>
<td><code>C-c C-d</code></td>
<td>设置任务截止时间</td>
<td></td>
</tr>
<tr>
<td><code>C-c C-t</code></td>
<td>改变任务状态</td>
<td></td>
</tr>
<tr>
<td><code>S-Up/Down</code></td>
<td>设置任务优先级 [#A], [#B], [#C]</td>
<td></td>
</tr>
<tr>
<td><code>C-c C-x C-i</code></td>
<td>开始任务计时</td>
<td></td>
</tr>
<tr>
<td><code>C-c C-x C-o</code></td>
<td>终止任务计时</td>
<td></td>
</tr>
<tr>
<td><code>C-c [</code></td>
<td>将当前文件加入 Org-Agenda</td>
<td></td>
</tr>
<tr>
<td><code>C-c ]</code></td>
<td>将当前文件从 Org-Agenda 移除</td>
<td></td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>Shortcuts</th>
<th>功能</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>t</code></td>
<td>在 Org-Agenda 的任务条目上， 修改任务状态。</td>
<td></td>
</tr>
<tr>
<td><code>C-c C-x C-a</code></td>
<td>归档</td>
<td></td>
</tr>
<tr>
<td><code>C-c C-w</code></td>
<td>activate refile</td>
<td></td>
</tr>
<tr>
<td><code>I</code></td>
<td>在 Org-Agenda 的任务条目上， 开始计时。</td>
<td></td>
</tr>
<tr>
<td><code>O</code></td>
<td>在 Org-Agenda 的任务条目上， 终止计时。</td>
<td></td>
</tr>
<tr>
<td><code>z</code></td>
<td>在任务上添加 note</td>
<td></td>
</tr>
<tr>
<td><code>R</code></td>
<td>clock mode, 显示耗时。</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="org-grammar">Org grammar</h2>
<p>This is almost anything you need to know about Org mode syntax:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-org" data-lang="org"><span style="display:flex;"><span> <span style="color:#66d9ef">* </span>This Is A Heading
</span></span><span style="display:flex;"><span> ** This Is A Sub-Heading
</span></span><span style="display:flex;"><span> *** And A Sub-Sub-Heading
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> Paragraphs are separated by at least one empty line. <span style="font-weight:bold">*bold*</span> <span style="font-style:italic">/italic/</span> _underlined_ <span style="color:#f92672">+strikethrough+</span> <span style="color:#a6e22e">=monospaced=</span>
</span></span><span style="display:flex;"><span> [[<span style="color:#a6e22e">http://Karl-Voit.at</span>][<span style="color:#f92672">Link description</span>]]
</span></span><span style="display:flex;"><span> http://Karl-Voit.at → link without description
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">- </span>list item
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">- </span>another item
</span></span><span style="display:flex;"><span>   <span style="color:#66d9ef">- </span>sub-item
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">1.</span> also enumerated
</span></span><span style="display:flex;"><span>     <span style="color:#66d9ef">2.</span> if you like
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">- [ ]</span> yet to be done
</span></span><span style="display:flex;"><span> <span style="color:#66d9ef">- [X]</span> item which is done
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span> : Simple pre-formatted text such as for source code.
</span></span><span style="display:flex;"><span> : This also respects the line breaks. <span style="font-weight:bold">*bold*</span> is not bold here.
</span></span></code></pre></div><p>code block</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span>myresult <span style="color:#f92672">=</span> <span style="color:#ae81ff">42</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">23</span>
</span></span><span style="display:flex;"><span>print(<span style="color:#e6db74">&#39;Hello Europe! &#39;</span> <span style="color:#f92672">+</span> str(myresult))
</span></span></code></pre></div><p>table</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-org" data-lang="org"><span style="display:flex;"><span> <span style="color:#e6db74">| My Column 1 | My Column 2 | Last Column |</span>
</span></span><span style="display:flex;"><span> <span style="color:#e6db74">|-------------+-------------+-------------|</span>
</span></span><span style="display:flex;"><span> <span style="color:#e6db74">|          42 | foo         | bar         |</span>
</span></span><span style="display:flex;"><span> <span style="color:#e6db74">|          23 | baz         | abcdefg     |</span>
</span></span><span style="display:flex;"><span> <span style="color:#e6db74">|-------------+-------------+-------------|</span>
</span></span><span style="display:flex;"><span> <span style="color:#e6db74">|          65 |             |             |</span>
</span></span></code></pre></div><h2 id="export-to-markdown">Export to Markdown</h2>
<p>这里用的是 <a href="https://github.com/kawabata/ox-pandoc">ox-pandoc</a>， ~M-x org-pandoc-export-as-gfm~算是我找到最符合 MarkDown 语法的转换了，Emacs 自己的转换会将 Table 转换成 HTML 标签的格式。</p>
]]></content:encoded>
    </item>
    
    <item>
      <title>Figma</title>
      <link>https://luciuschen.github.io/posts/20220503154744-figma/</link>
      <pubDate>Sat, 04 Jun 2022 20:05:05 +0800</pubDate>
      
      <guid>https://luciuschen.github.io/posts/20220503154744-figma/</guid>
      <description>Plugin Scale Scale any frame, it’s contents, and all effects to any defined width or height. Sankey Connect Sankey Diagram Connect. </description>
      <content:encoded><![CDATA[<h2 id="plugin">Plugin</h2>
<ul>
<li><a href="https://www.figma.com/community/plugin/836326694968364056/Scale">Scale</a> Scale any frame, it’s contents, and all effects to any defined width or height.</li>
<li><a href="https://www.figma.com/community/plugin/991975059967102509/Sankey-Connect">Sankey Connect</a> Sankey Diagram Connect.</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Build Diagram</title>
      <link>https://luciuschen.github.io/posts/20220503145636-build_diagram/</link>
      <pubDate>Sat, 04 Jun 2022 20:03:34 +0800</pubDate>
      
      <guid>https://luciuschen.github.io/posts/20220503145636-build_diagram/</guid>
      <description>Sankey diagram 使用软件：Figma Plugin: Sankey Connect 展现数据流动的利器 案例：工作流描述 初始的思路是按照流程图来画，用 Excalidraw 插件画起来很快，但不够明晰。工作流也是处理数</description>
      <content:encoded><![CDATA[<h2 id="sankey-diagram">Sankey diagram</h2>
<ul>
<li>使用软件：<a href="/posts/20220503154744-figma/">Figma</a>
<ul>
<li>Plugin: Sankey Connect</li>
</ul>
</li>
<li>展现数据流动的利器</li>
<li>案例：工作流描述
<ul>
<li>
<p>初始的思路是按照流程图来画，用 Excalidraw 插件画起来很快，但不够明晰。工作流也是处理数据流动的过程，适合用 Sankey diagram 来展示。</p>
</li>
<li>
<p>对比</p>
<figure>
            <img loading="lazy" src="/ox-hugo/take-notes-draft.png"
                 alt="Figure 1: take-notes-draft"/> <figcaption>
                    <p><!-- raw HTML omitted -->Figure 1: <!-- raw HTML omitted -->take-notes-draft</p>
                </figcaption>
        </figure>

<figure>
            <img loading="lazy" src="/ox-hugo/take-notes-draft_1.png"
                 alt="Figure 2: take-notes-draft_1"/> <figcaption>
                    <p><!-- raw HTML omitted -->Figure 2: <!-- raw HTML omitted -->take-notes-draft_1</p>
                </figcaption>
        </figure>

<figure>
            <img loading="lazy" src="/ox-hugo/take-notes-sankey.png"
                 alt="Figure 3: take-notes-sankey"/> <figcaption>
                    <p><!-- raw HTML omitted -->Figure 3: <!-- raw HTML omitted -->take-notes-sankey</p>
                </figcaption>
        </figure>

</li>
<li>
<p>技巧</p>
<ul>
<li>Connect 的渐变色是将颜色从 Solid 改为 Linear，然后把两端的色块拖动到 Node 处并改为对应 Node 的颜色。</li>
<li>Connect 要尽量弧度舒缓，有美感；留白要均匀。</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="heat-map">Heat Map</h2>
<ul>
<li>
<p>使用软件：Figma</p>
</li>
<li>
<p>展现过程中频次高低</p>
</li>
<li>
<p>案例：描述 GTD 和 Note-Taking 过程中思考频次高低。</p>
<figure>
        <img loading="lazy" src="/ox-hugo/gtd_note_taking_dark.png"
             alt="Figure 4: gtd_note_taking_dark"/> <figcaption>
                <p><!-- raw HTML omitted -->Figure 4: <!-- raw HTML omitted -->gtd_note_taking_dark</p>
            </figcaption>
    </figure>

<figure>
        <img loading="lazy" src="/ox-hugo/gtd_note_taking_light.png"
             alt="Figure 5: gtd_note_taking_light"/> <figcaption>
                <p><!-- raw HTML omitted -->Figure 5: <!-- raw HTML omitted -->gtd_note_taking_light</p>
            </figcaption>
    </figure>

</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>How I Take Notes</title>
      <link>https://luciuschen.github.io/posts/20220505162419-how_i_take_notes/</link>
      <pubDate>Sat, 04 Jun 2022 19:52:40 +0800</pubDate>
      
      <guid>https://luciuschen.github.io/posts/20220505162419-how_i_take_notes/</guid>
      <description>Introduction 最先接触到 Zettlekasten (German: &amp;ldquo;slip box&amp;rdquo;, plural zettlekästen) 是从 @Tisoga 的推文中得知，如获至宝。在这之前用过 MWeb（内测用户）、iA Writer、Bear、</description>
      <content:encoded><![CDATA[<h2 id="introduction">Introduction</h2>
<p>最先接触到 <a href="https://en.wikipedia.org/wiki/Zettelkasten">Zettlekasten</a> (German: &ldquo;slip box&rdquo;, plural zettlekästen) 是从 @Tisoga 的推文中得知，如获至宝。在这之前用过 MWeb（内测用户）、iA Writer、Bear、Notion、Obsidian（当时还不知道 Backlinks），都觉得不太合适，尤其是第一步文件夹的分类就让我头疼，很多内容是互相交叉的，并不是简单的可以归在一个分类下面，若是细分的分类过多，又会过于混乱，最后的结果就是“垃圾场”。</p>
<ul>
<li>根据 Zettlekasten 衍生出来的各种 APP 中的 Backlinks 将笔记串联起来，作为一个草稿箱，定期去整理回顾形成自己的知识。</li>
</ul>
<p>另外一个极为吸引我的就是 Daily Notes 或者 Journals，非常适合我当前的工作场景。「生产问题」或者「零碎的需求」会不断从打断我的工作，有时候会非常紧急需要优先处理「需求」或者「生产问题」，解决后会有两种情况。</p>
<ul>
<li>
<p>问题或需求解决后，要花一些时间梳理之前在做的事情才能够重新接续之前的思路继续工作。</p>
</li>
<li>
<p>问题解决后几个月遇到相同或类似的问题，虽然记得解决过，但是当时解决的思路以及细节需要注意的地方就模糊不清了。通常为了万无一失需要重复上次的工作，仔细查看过代码结合业务后，才能作出正确的判断，确保干净利落地解决问题。</p>
</li>
</ul>
<p>上面两种情况完全可以用 Journals 记录解决问题前的工作思路，记录解决问题后的思路，来避免上述两种情况发生。</p>
<figure>
    <img loading="lazy" src="/ox-hugo/take-notes-sankey.png"
         alt="Figure 1: take-notes-sankey"/> <figcaption>
            <p><!-- raw HTML omitted -->Figure 1: <!-- raw HTML omitted -->take-notes-sankey</p>
        </figcaption>
</figure>

<p>信息大爆炸的副作用就是信噪比降低，通过分阶段的信息处理，不断地归纳、处理形成自己的想法，并将其固化下来，作为知识库。</p>
<h2 id="流程设计">流程设计</h2>
<ol>
<li>
<p>图中的流程其实就是多层的过滤器。</p>
<p>从最初的信息源处到 Logseq 的过程，只需要考虑这个信息源是否值得读，是否值得扩展，答案确定则大胆地记入 Logseq。其中零散的思绪及文章阅读记录在 Journals 中，书籍这类大部头则在 page 中记录，前者因为零散在 Journals 中，需要加 page 的双链或 Tag。</p>
<p>Logseq 中 Journals 中的事件重要的会被我移到 Org-roam 中的 Journals.org 文件中，这个文件类似于日记的作用，并不是每天都会记录，记录多了之后按照年份进行分割。</p>
<p>从 Logseq 到 Org-roam 则是知识固化的过程，需要考虑该知识是否以后会被自己再次用到，是否值得扩展，答案确定则精炼后记入，并标明灵感来源，引用材料。因此，Logseq 中记录的都只能算是草稿，需要再次的整合，提高信噪比。</p>
</li>
<li>
<p>对信息源处理时，可以用 Excalidraw 进行流程图、思维图等图的草稿绘制。后续有时间的时候再用 Figma 重新绘制，视觉和逻辑上的重新设计，使得阐述的内容更加直观。</p>
<p>对于产品来说，通过<a href="/posts/20220503145636-build_diagram/">设计降低理解门槛和使用门槛</a>，是一件挺重要的事情。输出文章同样如此。</p>
</li>
<li>
<p>Org-roam 中也有收集想法的地方，Inbox.org，定期会进行清理。 notes 中 outline 结构是由 <code>*</code> 实现的，导出时是标题格式，为了随时可以导出发布，要注意 outline 结构。输出是通过 Org-export-dispatch 来转为 .md 或 .html 文件，为了更符合使用的格式，在 <a href="/posts/20220505220832-org_roam/">Org-roam</a> 中做了一些设置。</p>
</li>
<li>
<p>Org-roam-ui 非常优秀，不管是 UI 还是操作性，可以明晰的查看笔记之间的关联，知识是否形成闭环，哪些知识还需要进行拓展阅读。</p>
</li>
</ol>
<h2 id="准则">准则</h2>
<ul>
<li>
<p>卡片应该具有原子性。这点和编程的原则很像，一个方法只做一件事，在这里也就是只记录一个主题的内容。</p>
</li>
<li>
<p>卡片内容应该具有独立性。这点和上面并不冲突，设想一下，为了保持每个卡片的纯净，X 和 Y 之间的关系，你可能会用 Z 去链接他们。但回顾的时候，没有 Z，单纯回顾 X 或 Y 无法得知两者之间的关联。所以这里不管在 X 或者 Y 中去描述与对方的关系都是可以的，一点点内容的冗余可以使得内容更加独立。</p>
</li>
<li>
<p>遵守奥卡姆剃刀原则。对新工具充分调研，是否满足自己的需求后再考虑替换或增加到现有工作流当中。</p>
</li>
<li>
<p>Literature Notes 需要及时回顾，在一两天内转化为 Permanent Notes 或者直接删掉。</p>
</li>
</ul>
<h2 id="误区">误区</h2>
<ul>
<li>
<p>All-In-One 的思想。Markdown 的扩展语法实现并不统一，扩展语法的内容导出时经常要手动兼容，或不可再用。云端服务的不可持续性，互联网这么多年已经太多的云端服务用着用着就停掉了。</p>
</li>
<li>
<p>Permanent Notes 并不是不需要回顾和修改了。</p>
</li>
<li>
<p>记太多的内容。从资料中复制大量的原文。笔记应该是对所读内容的提炼：用自己的话改写观点和概念有助于加强理解。</p>
</li>
<li>
<p>太复杂的笔记流程。复杂的工作流通常需要自动化，但自动化不利于笔记的整理，形成最重笔记时应该慎重考虑哪些是需要保留的，否则知识库就会变成垃圾场。</p>
</li>
</ul>
]]></content:encoded>
    </item>
    
    <item>
      <title>Implementation Intention GTD</title>
      <link>https://luciuschen.github.io/posts/20220503143427-gtd/</link>
      <pubDate>Sat, 04 Jun 2022 17:20:48 +0800</pubDate>
      
      <guid>https://luciuschen.github.io/posts/20220503143427-gtd/</guid>
      <description>f* Introduction 2013年时，第一次接触到 GTD 是因为 Omnifocus 的美观，为此我还花了 $9.99 买了 iOS 的客户端。但从那个时候起，我一直没有用好 GTD 这套理论和各种工具，例如 Omn</description>
      <content:encoded><![CDATA[<p>f* Introduction</p>
<p>2013年时，第一次接触到 GTD 是因为 Omnifocus 的美观，为此我还花了 $9.99 买了 iOS 的客户端。但从那个时候起，我一直没有用好 GTD 这套理论和各种工具，例如 Omnifocus、Things 等等。</p>
<p>一直不明白问题出在哪里，一天下来不管是 Today 还是 Inbox 当中的 To-Do 不仅没有变少，甚至更多了。自我怀疑、自我谴责让自己觉得是拖延症、懒造成了 To-Do 积压。</p>
<p>回顾过去几年中，除了 Things 以外，我还使用了 Due 和 Fantastical 这两款软件。前者是吃药的时候，循环提醒该吃药了；后者是今天或者未来某天必须要做的事情，为了不让我忘记这个事情，哪怕我不确定这个事情在当天的哪个时间段做，都会给它加一个提醒，这样即便是过了时间，只要没有 checked 就会一直在锁屏或者下拉通知内，这样我就可以*不断地被提醒，找到合适的时间段去完成这件事情*​。</p>
<p>至于 Things 时常被我厌恶，因为我有太多的 To-Do 积压在里面。每次打开它都有种翻开垃圾桶的感觉，没错，它就是垃圾桶。我再次捡起 Things 用的时候，基本都是我把“过期了的”、“没有意义的” To-Do 清空了才可以。这是一个循环往复的过程，过程中不断地伤害着我自己的自信心，并让我感到焦虑，永远做不完的事情，越积越多。</p>
<p>在这样的情况下我了解到了 <a href="https://en.wikipedia.org/wiki/Implementation_intention">Implementation Intention</a>。</p>
<h2 id="implementation-intention">Implementation Intention</h2>
<blockquote>
<p>执行意图由心理学家 Peter M.Gollitzer 提出，是个体为实现某一目标制定的一种计划，表现为“如果－那么”形式，例如“如果我遇到突发情况，那么我将保持冷静”。</p>
<p>普通人思考目标的时候，使用的是目标意图，即：我要做什么、我要成为什么。目标意图有个最大的缺点：建立目标容易，执行目标很难。而执行意图更多思考的是要怎么做的问
题。</p>
<p>执行意图明确了个体在何时何地，以什么方式来实现目标，从而让个体更加容易地提取具体情景线索的心理表征，并通过这些线索建立起与目标所指行为的联系。在建立起线索和目标行为的联系之后，个体在随后遇到线索所指向的情景时（如考场），便可以用一种自动化的方式执行事先形成的计划，达成预设的目标。重要的是，执行意图的这种过程是自动化进行的，并不需要个体有意识地进行控制。</p>
</blockquote>
<p>再结合成功实行 GTD 的案例「<a href="https://www.calnewport.com/blog/2013/12/21/deep-habits-the-importance-of-planning-every-minute-of-your-work-day/">Deep Habits: The Importance of Planning Every Minute of Your Work Day</a>」和「<a href="https://www.nirandfar.com/todo-vs-schedule-builder/">Be a Schedule Builder, Not a To-Do List Maker</a>」，发现他们都会去在前一天花费一些时间去细化第二天的任务列表，甚至精确到分钟，这其实就是上面提到的 Implementation Intention 的实际操作，When Where and How。</p>
<p>案例1当中是通过日历来安排一天的工作，细致到分钟。若发生变故需要变更，则在右侧重新记录变更后的安排。</p>
<figure>
    <img loading="lazy" src="/Users/luciuschen/Dropbox/PKM/assets/gtd_dark.png"
         alt="Figure 1: gtd_dark"/> <figcaption>
            <p><!-- raw HTML omitted -->Figure 1: <!-- raw HTML omitted -->gtd_dark</p>
        </figcaption>
</figure>

<p>案例2中则从容很多，不仅仅是安排了工作的内容，休闲娱乐的内容也会排在日历当中。(下图来自于案例2)</p>
<figure>
    <img loading="lazy" src="/Users/luciuschen/Dropbox/PKM/assets/gtd_schedule_builder.png"
         alt="Figure 2: gtd_schedule_builder"/> <figcaption>
            <p><!-- raw HTML omitted -->Figure 2: <!-- raw HTML omitted -->gtd_schedule_builder</p>
        </figcaption>
</figure>

<p>其实回顾到上面我提到使用 Due 和 Fantastical 的经历，当中已经包含了执行意图的概念，任务都非常明晰，是今天必须要做的，是今天有非常合适的情景去做的，只不过是我没有意识到。</p>
<h3 id="执行意图-会让人主动思考-避免囤积过多的任务">「执行意图」会让人主动思考，避免囤积过多的任务。</h3>
<p>举个例子，按照执行意图的方法。如果我买了一本书，那么我就要在最近的闲暇时间都去读它，并在读完后写读后感总结一下。那么当我买书或者安排任务的时候就会想到买书不仅仅是一个完结，后续意味着我要去读它，并写读后感等一大堆的操作，这样就不会去在自己当前书还没有读完的情况下，就去安排下一本书。</p>
<p>例子中的场景和平时从 Inbox 中安排任务很类似，造成任务完不成，积压，是因为没有安排好任务的情景关系，何时、何地、如何去做这件事情，仅仅就是目标意图，我要做这些事情。</p>
<p>没有对每个任务细致的思考前，无法把握任务的工作量，适合完成的场景，也就无法把控今天安排的任务是否都能完成。但刚刚开始接触这套方法的人，难免会因为对工作细节不熟悉导致工作量评估不准确的情况。</p>
<h3 id="执行意图-消除了在何时何地做某事的模糊性">「执行意图」消除了在何时何地做某事的模糊性。</h3>
<p>例如，询问选民如何前往投票站等简单的问题，已经被证明可以提高当天的投票率。</p>
<p>在这个例子当中，被问的选民其实受到了引导，增加去投票这件事情的确定性。我们也可以利用同样的方法，明确任务，顺着 <code>if...then...</code> 的顺序去完成任务。</p>
<h2 id="回顾">回顾</h2>
<p><a href="https://twitter.com/mikhails5v/status/1521406633548697603">@mikhails5v</a> 在 tweet thread 中提到了他在使用 Things 的 1.5 年中，对于没有完成的任务，在每晚回顾时，手动的去把今天的任务清空，已完成的任务会让他很有成就感；未完成的任务则在思考后移到后面适合的时候，或者重新放回 Inbox，甚至删掉它们。确保了每日的任务都是清空的状态，没有负罪感。即便是没有完成的任务，在每晚也会重新回顾，思考后续是否有合适的情景去完成它，或者干脆觉得没有执行的必要删除掉。</p>
<h2 id="阶段性思考">阶段性思考</h2>
<blockquote>
<p>note-taking and knowledge creation will always require large amounts of brain work. On the other hand, GTD makes task management a simple, effortless process.</p>
</blockquote>
<p>对比我在 <a href="/posts/20220505162419-how_i_take_notes/">How I Take Notes</a> 中写的笔记的工作流，To-Do 和 Note-Taking 确实存在区别。</p>
<p>GTD 中 Capture 是最不需要思考的，有什么东西直接记录到 Inbox 当中，清空当前的灵感，专注眼前的事情。例如，Things 中快速呼出 Inbox 的输入框；Org-roam 中写在 <code>.org</code> 文件中的 To-Do 都会集中在 Agenda 中；Logseq 中写在 Journals 中的 To-Do 也可以在 Pages 中按照自己的需求定制查询（复杂的查询有些门槛）。后续处理，按照执行意图的方法去评估 To-Do 适合的情景；较大的任务需要进行拆分成若干小任务，甚至形成一个专门的项目分为不同阶段去完成。</p>
<p>Note-Taking 相反，从阅读就开始思考，随后各种灵感迸发，记录下来进行整理，去芜存菁后继续扩展，定期回顾后形成自己的知识并输出，这个时候的写作反而是最不需要动脑的部分了。以下的 Heat Map 表示不同阶段思考的程度。</p>
<figure>
    <img loading="lazy" src="/Users/luciuschen/Dropbox/PKM/assets/gtd_note_taking_dark.png"
         alt="Figure 3: gtd_note_taking_dark"/> <figcaption>
            <p><!-- raw HTML omitted -->Figure 3: <!-- raw HTML omitted -->gtd_note_taking_dark</p>
        </figcaption>
</figure>

<h2 id="to-do-是否需要独立管理">To-Do 是否需要独立管理</h2>
<p>至于 To-Do 和 Note-Taking 是否分开，我的看法是逻辑上分开，物理上并不一定分开。</p>
<p>一天 24 小时是由不同阶段组成的，工作、生活、娱乐等等，都会产生 To-Do。那么管理 To-Do 也可以分为不同的场景。</p>
<h3 id="工作">工作</h3>
<p>工作上做好日志记录，是个好习惯，可以方便查阅当时的想法，解决问题的思路，以及相关人员是谁，就跟航海日志一样。这个时候产生的 To-Do 就是与日志息息相关的，上下文联系紧密。加上 Capture 的原则是尽快记录，并且不打断现有的思路，最好的方法就是记录在笔记当中（比如Logseq 的 Journals）。</p>
<p>汇总的话就更加简单了，Logseq 通过 Clojure 的查询语句就可以完成汇总，不会这门语言也没有关系，Discord 中有专门的 Channel 可以提问或讨论。每天上班的第一件事情就是回顾汇总，结合工作进度安排今天的工作。</p>
<h3 id="生活">生活</h3>
<p>生活中琐事居多，场景也非常繁杂，这个时候完全可以用单独的 App 来进行管理。Things 来收集拆分任务，Fantastical 来进行一天时间的分配以及未来几天需要提醒的任务，Due 来提醒重复任务。</p>
<h2 id="conclusion">Conclusion</h2>
<p>警惕 All-In-One 的想法，并不是所有场景都有统一的解决方案。工作和生活分开管理 To-Do 还有个好处，休假的时候你完全可以屏蔽掉工作的内容。</p>
<p>另外不管工作和生活中，长期计划用甘特图来管理还是非常不错的，确立里程碑，控制进度，把握长期计划的走向。</p>
]]></content:encoded>
    </item>
    
  </channel>
</rss>
